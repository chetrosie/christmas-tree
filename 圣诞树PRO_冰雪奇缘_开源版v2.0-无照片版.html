<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Christmas Tree - by å°çº¢ä¹¦@æ²«æ²«</title>
    <style>
        /* åŸºç¡€æ ·å¼ */
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #0b1a2a 0%, #000000 100%);
            font-family: 'Times New Roman', serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease-out;
        }

        .loader-text {
            color: #aaddff;
            font-size: 14px;
            letter-spacing: 4px;
            margin-top: 20px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 1px solid #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* æ ‡é¢˜ */
        h1 {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            text-align: center;
            margin: 0;
            pointer-events: none;
            font-size: 36px;
            font-weight: 400;
            background: linear-gradient(135deg, #e0f7fa 0%, #ffffff 50%, #88ccff 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: aurora-shine 6s linear infinite;
            opacity: 0.9;
        }

        @keyframes aurora-shine {
            0% { background-position: 0% center; }
            100% { background-position: 300% center; }
        }

        /* ä¸Šä¼ æŒ‰é’® */
        .upload-wrapper {
            position: absolute;
            top: 40px;
            right: 40px;
            z-index: 20;
            pointer-events: auto;
            display: flex;
            gap: 10px;
        }

        .upload-btn, .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            padding: 8px 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            text-transform: uppercase;
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-btn:hover, .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #00ffcc;
            color: #fff;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.2);
        }

        .control-btn.active {
            background: rgba(0, 255, 204, 0.1);
            border-color: #00ffcc;
            color: #00ffcc;
        }

        #file-input, #import-input {
            display: none;
        }

        /* æ‘„åƒå¤´é¢„è§ˆçª—å£ */
        #webcam-wrapper {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            opacity: 0.8;
            z-index: 20;
            background: #000;
        }

        #webcam-wrapper canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* æ“ä½œæç¤º */
        #tips {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 15px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 10px;
            backdrop-filter: blur(10px);
            z-index: 15;
        }

        .tip-item {
            margin: 6px 0;
        }

        .tip-key {
            color: #00ffcc;
            display: inline-block;
            min-width: 60px;
        }

        /* ç¼“å­˜ç®¡ç†æ¨¡æ€æ¡† */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: rgba(10, 20, 30, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            gap: 15px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            margin-left: auto;
            margin-right: 15px;
        }

        .modal-header h2 {
            margin: 0;
            color: #fff;
            font-size: 18px;
            font-weight: 400;
        }

        .modal-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .photo-item {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .photo-item:hover {
            border-color: #00ffcc;
            transform: translateY(-2px);
        }

        .photo-item.in-scene {
            border-color: #00ffcc;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .photo-thumb {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }

        .photo-info {
            padding: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
        }

        .photo-size {
            margin-bottom: 4px;
        }

        .photo-status {
            color: #00ffcc;
            font-size: 9px;
        }

        .photo-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .photo-action-btn {
            flex: 1;
            padding: 6px 4px;
            font-size: 9px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .photo-action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .photo-action-btn.add-scene {
            border-color: #00ffcc;
            color: #00ffcc;
        }

        .photo-action-btn.add-scene:hover {
            background: rgba(0, 255, 204, 0.1);
        }

        .photo-action-btn.remove-scene {
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .photo-action-btn.delete {
            border-color: #ff4444;
            color: #ff4444;
        }

        .photo-action-btn.delete:hover {
            background: rgba(255, 68, 68, 0.1);
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
        }

        .modal-action-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 8px 14px;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
        }

        .modal-action-btn.upload {
            border-color: #00ffcc;
            color: #00ffcc;
        }

        .modal-action-btn.upload:hover {
            background: rgba(0, 255, 204, 0.1);
        }

        .modal-action-btn.import {
            border-color: #88aaff;
            color: #88aaff;
        }

        .modal-action-btn.import:hover {
            background: rgba(136, 170, 255, 0.1);
        }

        .modal-action-btn.export {
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .modal-action-btn.export:hover {
            background: rgba(255, 170, 0, 0.1);
        }

        .cache-stats {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
        }

        .cache-stats .highlight {
            color: #00ffcc;
        }

        .cache-stats .warning {
            color: #ffaa00;
        }

        .clear-all-btn {
            padding: 8px 16px;
            font-size: 11px;
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid #ff4444;
            color: #ff4444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .clear-all-btn:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: rgba(255, 255, 255, 0.4);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        /* å¯¼å‡ºå‘½åå¯¹è¯æ¡†æ ·å¼ */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            margin-bottom: 5px;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            box-sizing: border-box;
        }

        .form-group input:focus {
            outline: none;
            border-color: #00ffcc;
        }

        .form-group input[readonly] {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .filename-preview {
            padding: 10px;
            background: rgba(0, 255, 204, 0.1);
            border-radius: 6px;
            color: #00ffcc;
            font-size: 12px;
            word-break: break-all;
        }

        /* éŸ³ä¹ç®¡ç†æ ·å¼ */
        .music-source-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .music-tab {
            flex: 1;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .music-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .music-tab.active {
            background: rgba(0, 255, 204, 0.1);
            border-color: #00ffcc;
            color: #00ffcc;
        }

        .music-tab-content {
            padding: 15px 0;
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #00ffcc;
            background: rgba(0, 255, 204, 0.05);
        }

        .upload-area.dragover {
            border-color: #00ffcc;
            background: rgba(0, 255, 204, 0.1);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .upload-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-bottom: 8px;
        }

        .upload-hint {
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
        }

        .current-music-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .music-info-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            margin-bottom: 5px;
        }

        .music-info-value {
            color: #00ffcc;
            font-size: 13px;
            word-break: break-all;
        }

        .music-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .music-control-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .music-control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #00ffcc;
            color: #00ffcc;
        }

        .music-control-btn.playing {
            background: rgba(0, 255, 204, 0.1);
            border-color: #00ffcc;
            color: #00ffcc;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            justify-content: flex-end;
        }

        .volume-label {
            font-size: 16px;
        }

        .volume-value {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            min-width: 35px;
        }

        #music-volume {
            width: 100px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        #music-volume::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #00ffcc;
            border-radius: 50%;
            cursor: pointer;
        }

        #music-volume::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #00ffcc;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* ========== éŸ³ä¹æ’­æ”¾åŠ¨æ•ˆæ ·å¼ ========== */
        .music-visualizer {
            position: fixed;
            left: 20px;
            bottom: 20px;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 30px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            cursor: pointer;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .music-visualizer:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(0, 255, 204, 0.3);
            transform: scale(1.05);
        }

        .music-visualizer .bar {
            width: 4px;
            background: linear-gradient(to top, #00ffcc, #88ccff);
            border-radius: 2px;
            animation: musicBar 0.5s ease-in-out infinite alternate;
        }

        .music-visualizer .bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .music-visualizer .bar:nth-child(2) { height: 16px; animation-delay: 0.1s; }
        .music-visualizer .bar:nth-child(3) { height: 24px; animation-delay: 0.2s; }
        .music-visualizer .bar:nth-child(4) { height: 12px; animation-delay: 0.3s; }
        .music-visualizer .bar:nth-child(5) { height: 20px; animation-delay: 0.4s; }

        .music-visualizer.paused .bar {
            animation: none;
            height: 6px !important;
            opacity: 0.5;
        }

        @keyframes musicBar {
            0% { transform: scaleY(0.3); }
            100% { transform: scaleY(1); }
        }

        /* ========== å¼€å…³æ ·å¼ ========== */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.2);
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #00ffcc;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        /* ========== é…ç½®é¢æ¿æ ·å¼ ========== */
        .settings-modal-content {
            max-width: 700px !important;
            width: 95%;
        }
        
        .settings-modal-content .modal-body {
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .settings-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
        }
        
        .settings-section-wide {
            grid-column: span 3;
        }
        
        /* é¢œè‰²è®¾ç½®æ ·å¼ */
        .color-settings-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px 20px;
        }
        
        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 10px 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .color-item label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 11px;
            text-align: center;
        }
        
        .color-item input[type="color"] {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: transparent;
            cursor: pointer;
            padding: 0;
        }
        
        .color-item input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 3px;
        }
        
        .color-item input[type="color"]::-webkit-color-swatch {
            border-radius: 5px;
            border: none;
        }
        
        .color-item input[type="color"]:hover {
            border-color: #00ffcc;
            box-shadow: 0 0 8px rgba(0, 255, 204, 0.3);
        }

        .section-title {
            color: #00ffcc;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .setting-item:last-child {
            margin-bottom: 0;
        }

        .setting-item label {
            flex: 1;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            min-width: 80px;
        }

        .setting-item input[type="range"] {
            flex: 2;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #00ffcc;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-item input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #00ffcc;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .setting-value {
            min-width: 35px;
            text-align: right;
            color: #00ffcc;
            font-size: 11px;
            font-family: monospace;
        }

        /* ========== ç§»åŠ¨ç«¯é€‚é… ========== */
        @media screen and (max-width: 768px) {
            /* æ ‡é¢˜é€‚é… */
            h1 {
                top: 15px;
                font-size: 22px;
                padding: 0 10px;
            }

            /* æŒ‰é’®åŒºåŸŸ - å³ä¸Šè§’ç«–å‘æ’åˆ—å°å›¾æ ‡ */
            .upload-wrapper {
                top: 10px;
                right: 10px;
                left: auto;
                transform: none;
                gap: 8px;
                flex-direction: column;
                flex-wrap: nowrap;
                justify-content: flex-start;
                align-items: flex-end;
            }

            .upload-btn, .control-btn {
                padding: 8px;
                font-size: 14px;
                gap: 0;
                border-radius: 50%;
                width: 36px;
                height: 36px;
                min-width: 36px;
            }

            /* ç§»åŠ¨ç«¯éšè—æŒ‰é’®æ–‡å­—ï¼Œåªæ˜¾ç¤ºå›¾æ ‡ */
            .control-btn .btn-text {
                display: none;
            }
            
            .control-btn .btn-icon {
                font-size: 16px;
                color: rgba(255, 255, 255, 0.8);
            }

            .mobile-ctrl-btn i {
                font-size: 22px;
            }

            /* æ“ä½œæç¤º - ç§»åŠ¨ç«¯éšè—ï¼Œå› ä¸ºæœ‰åº•éƒ¨è§¦æ‘¸æŒ‰é’® */
            #tips {
                display: none;
            }

            /* æ‘„åƒå¤´é¢„è§ˆ - ç§»åŠ¨ç«¯ç¼©å° */
            #webcam-wrapper {
                width: 100px;
                height: 75px;
                bottom: 5px;
                right: 5px;
            }

            /* æ¨¡æ€æ¡†é€‚é… */
            .modal-content {
                width: 95%;
                max-height: 90vh;
                border-radius: 8px;
            }

            .modal-header {
                padding: 15px;
                flex-wrap: wrap;
            }

            .modal-header h2 {
                font-size: 16px;
                width: 100%;
                margin-bottom: 10px;
            }

            .header-actions {
                margin-left: 0;
                margin-right: 0;
                width: 100%;
                justify-content: flex-start;
                flex-wrap: wrap;
                gap: 6px;
            }

            .modal-action-btn {
                padding: 8px 10px;
                font-size: 10px;
            }

            .modal-body {
                padding: 15px;
            }

            .photo-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
            }

            .photo-info {
                padding: 6px;
                font-size: 9px;
            }

            .photo-action-btn {
                padding: 5px 3px;
                font-size: 8px;
            }

            /* é…ç½®é¢æ¿ç§»åŠ¨ç«¯é€‚é… */
            .settings-modal-content {
                max-width: 95% !important;
            }
            
            .settings-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .settings-section {
                padding: 8px;
            }
            
            .settings-section-wide {
                grid-column: span 2;
            }

            .section-title {
                font-size: 11px;
                margin-bottom: 8px;
            }

            .setting-item {
                flex-wrap: wrap;
                gap: 5px;
            }

            .setting-item label {
                width: 100%;
                font-size: 10px;
                margin-bottom: 2px;
            }

            .setting-item input[type="range"] {
                flex: 1;
            }

            .setting-value {
                min-width: 30px;
            }
            
            .color-settings-row {
                gap: 10px;
            }
            
            .color-item {
                flex: 1;
                min-width: 70px;
            }
            
            .color-item label {
                font-size: 10px;
                min-width: 35px;
                font-size: 10px;
            }

            .modal-footer {
                padding: 12px 15px;
                flex-direction: column;
                gap: 10px;
            }

            .cache-stats {
                font-size: 11px;
                text-align: center;
            }

            /* éŸ³ä¹æ§åˆ¶é€‚é… */
            .music-controls {
                flex-wrap: wrap;
                gap: 8px;
            }

            .music-control-btn {
                padding: 8px 15px;
                font-size: 11px;
            }

            .volume-control {
                width: 100%;
                justify-content: center;
                margin-top: 5px;
            }

            #music-volume {
                width: 150px;
            }

            .music-source-tabs {
                flex-direction: column;
                gap: 8px;
            }

            .upload-area {
                padding: 30px 15px;
            }

            .upload-icon {
                font-size: 36px;
            }

            .upload-text {
                font-size: 13px;
            }

            /* è¡¨å•é€‚é… */
            .form-group input {
                padding: 12px;
                font-size: 16px; /* é˜²æ­¢iOSç¼©æ”¾ */
            }

            /* éŸ³ä¹åŠ¨æ•ˆç§»åŠ¨ç«¯é€‚é… */
            .music-visualizer {
                left: 10px;
                bottom: 10px;
                padding: 6px 10px;
                height: 24px;
            }

            .music-visualizer .bar {
                width: 3px;
            }
        }

        /* æ›´å°å±å¹•é€‚é… */
        @media screen and (max-width: 480px) {
            h1 {
                top: 15px;
                font-size: 20px;
            }

            .upload-wrapper {
                top: 10px;
                right: 10px;
            }

            .upload-btn, .control-btn {
                padding: 6px 10px;
                font-size: 10px;
            }

            #tips {
                font-size: 10px;
                padding: 10px;
            }

            .photo-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶æŒ‰é’® */
        #mobile-controls {
            display: none;
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 25;
            gap: 15px;
            pointer-events: auto;
        }

        @media screen and (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
            /* ç§»åŠ¨ç«¯éšè—é”®ç›˜æç¤º */
            #tips .keyboard-tips {
                display: none;
            }
        }

        .mobile-ctrl-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-ctrl-btn:active {
            transform: scale(0.95);
            background: rgba(0, 255, 204, 0.3);
            border-color: #00ffcc;
        }

        .mobile-ctrl-btn.active {
            background: rgba(0, 255, 204, 0.2);
            border-color: #00ffcc;
            color: #00ffcc;
        }

        /* å®‰å…¨åŒºåŸŸé€‚é… (iPhone X+) */
        @supports (padding: max(0px)) {
            #tips {
                padding-bottom: max(12px, env(safe-area-inset-bottom));
            }
            #mobile-controls {
                bottom: max(100px, calc(80px + env(safe-area-inset-bottom)));
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://testingcf.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://testingcf.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://testingcf.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
    <!-- Font Awesome å›¾æ ‡åº“ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body></body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>
        <div class="upload-wrapper">
            <button class="control-btn" id="manage-btn" title="ç®¡ç†ç¼“å­˜ç…§ç‰‡"><i class="btn-icon fa-solid fa-folder-open"></i><span class="btn-text">ç®¡ç†</span></button>
            <button class="control-btn" id="music-btn" title="æ’­æ”¾/æš‚åœéŸ³ä¹"><i class="btn-icon fa-solid fa-music"></i><span class="btn-text">éŸ³ä¹</span></button>
            <button class="control-btn" id="settings-btn" title="å‚æ•°è®¾ç½®"><i class="btn-icon fa-solid fa-gear"></i><span class="btn-text">è®¾ç½®</span></button>
        </div>
        <!-- ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶æŒ‰é’® -->
        <div id="mobile-controls">
            <button class="mobile-ctrl-btn" id="mobile-tree" title="åœ£è¯æ ‘æ¨¡å¼"><i class="fa-solid fa-tree"></i></button>
            <button class="mobile-ctrl-btn" id="mobile-scatter" title="æ˜Ÿæ²³æ•£å¼€"><i class="fa-solid fa-star"></i></button>
            <button class="mobile-ctrl-btn" id="mobile-photo" title="é”å®šç…§ç‰‡"><i class="fa-solid fa-image"></i></button>
            <button class="mobile-ctrl-btn" id="mobile-next" title="ä¸‹ä¸€å¼ "><i class="fa-solid fa-forward"></i></button>
        </div>
    </div>

    <!-- èƒŒæ™¯éŸ³ä¹ -->
    <audio id="bg-music"></audio>
    
    <!-- éŸ³ä¹æ’­æ”¾åŠ¨æ•ˆ -->
    <div id="music-widget" class="music-widget">
        <div class="music-widget-main">
            <div id="music-visualizer" class="music-visualizer paused">
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
            </div>
            <div class="music-name" id="music-widget-name">Christmas Background</div>
        </div>
        <div class="music-widget-controls">
            <button class="widget-btn" id="widget-play-btn" title="æ’­æ”¾/æš‚åœ">â¸</button>
            <button class="widget-btn" id="widget-next-btn" title="ä¸‹ä¸€é¦–">â­</button>
            <button class="widget-btn" id="widget-settings-btn" title="éŸ³ä¹è®¾ç½®">âš™</button>
        </div>
    </div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline style="display:none;"></video>
        <canvas id="webcam-preview"></canvas>
    </div>

    <!-- ç¼“å­˜ç®¡ç†æ¨¡æ€æ¡† -->
    <div id="cache-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ç…§ç‰‡ç¼“å­˜ç®¡ç†</h2>
                <div class="header-actions">
                    <label class="modal-action-btn upload">
                        ğŸ“· ä¸Šä¼ ç…§ç‰‡
                        <input type="file" id="file-input" multiple accept="image/*" style="display:none;">
                    </label>
                    <label class="modal-action-btn import">
                        ğŸ“¥ å¯¼å…¥
                        <input type="file" id="import-input" accept=".json" style="display:none;">
                    </label>
                    <button class="modal-action-btn export" id="export-btn">ğŸ“¤ å¯¼å‡º</button>
                </div>
                <button class="modal-close" id="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div id="photo-grid" class="photo-grid"></div>
            </div>
            <div class="modal-footer">
                <div class="cache-stats" id="cache-stats">
                    å·²ç¼“å­˜ <span class="highlight">0</span> å¼ ç…§ç‰‡ (<span class="highlight">0 KB</span> / 50 MB)
                </div>
                <button class="clear-all-btn" id="clear-all-btn">æ¸…ç©ºå…¨éƒ¨</button>
            </div>
        </div>
    </div>

    <!-- å¯¼å‡ºå‘½åå¯¹è¯æ¡† -->
    <div id="export-name-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h2>å¯¼å‡ºç…§ç‰‡</h2>
                <button class="modal-close" id="export-name-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>ä¸»é¢˜å</label>
                    <input type="text" id="export-theme" value="Merry Christmas">
                </div>
                <div class="form-group">
                    <label>è‡ªå®šä¹‰åç§°</label>
                    <input type="text" id="export-custom" placeholder="ä¾‹ï¼šå¥³æœ‹å‹é“ç…§åˆé›†">
                </div>
                <div class="form-group">
                    <label>æ—¥æœŸ</label>
                    <input type="text" id="export-date" readonly>
                </div>
                <div class="filename-preview">
                    é¢„è§ˆ: <span id="filename-preview"></span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-action-btn" id="export-cancel">å–æ¶ˆ</button>
                <button class="modal-action-btn export" id="export-confirm">ç¡®è®¤å¯¼å‡º</button>
            </div>
        </div>
    </div>

    <!-- éŸ³ä¹ç®¡ç†å¯¹è¯æ¡† -->
    <div id="music-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>ğŸµ éŸ³ä¹ç®¡ç†</h2>
                <button class="modal-close" id="music-modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="music-source-tabs">
                    <button class="music-tab active" data-tab="url">ğŸ”— éŸ³ä¹é“¾æ¥</button>
                    <button class="music-tab" data-tab="upload">ğŸ“ ä¸Šä¼ æ–‡ä»¶</button>
                </div>

                <div class="music-tab-content" id="tab-url">
                    <div class="form-group">
                        <label>è¾“å…¥éŸ³ä¹é“¾æ¥ (æ”¯æŒ MP3, WAV, OGG ç­‰æ ¼å¼)</label>
                        <input type="text" id="music-url-input" placeholder="https://example.com/music.mp3">
                    </div>
                    <button class="modal-action-btn upload" id="apply-url-btn" style="width: 100%;">åº”ç”¨é“¾æ¥</button>
                </div>

                <div class="music-tab-content" id="tab-upload" style="display: none;">
                    <div class="form-group">
                        <label>é€‰æ‹©æœ¬åœ°éŸ³é¢‘æ–‡ä»¶</label>
                        <div class="upload-area" id="music-upload-area">
                            <div class="upload-icon">ğŸµ</div>
                            <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½éŸ³é¢‘æ–‡ä»¶åˆ°è¿™é‡Œ</div>
                            <div class="upload-hint">æ”¯æŒ MP3, WAV, OGG, M4A æ ¼å¼</div>
                            <input type="file" id="music-file-input" accept="audio/*" style="display: none;">
                        </div>
                    </div>
                </div>

                <div class="current-music-info" id="current-music-info">
                    <div class="music-info-label">å½“å‰éŸ³ä¹:</div>
                    <div class="music-info-value" id="current-music-name">é»˜è®¤éŸ³ä¹</div>
                </div>

                <div class="music-controls">
                    <button class="music-control-btn" id="music-play-btn">â–¶ æ’­æ”¾</button>
                    <button class="music-control-btn" id="music-pause-btn">â¸ æš‚åœ</button>
                    <button class="music-control-btn" id="music-next-btn">â­ ä¸‹ä¸€é¦–</button>
                    <div class="volume-control"></div>
                        <span class="volume-label">ğŸ”Š</span>
                        <input type="range" id="music-volume" min="0" max="100" value="50">
                        <span class="volume-value" id="volume-value">50%</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-action-btn" id="music-reset-btn">ğŸ”„ æ¢å¤é»˜è®¤</button>
                <button class="modal-action-btn export" id="music-close-btn">å®Œæˆ</button>
            </div>
        </div>
    </div>

    <!-- é…ç½®é¢æ¿æ¨¡æ€æ¡† -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content settings-modal-content">
            <div class="modal-header">
                <h2>âš™ï¸ å‚æ•°è®¾ç½®</h2>
                <button class="modal-close" id="settings-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-grid">
                    <!-- ç›¸æœºè®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">ğŸ“· ç›¸æœº</div>
                        <div class="setting-item">
                            <label>æ ‘æ¨¡å¼è·ç¦»</label>
                            <input type="range" id="cfg-tree-distance" min="20" max="80" value="45">
                            <span class="setting-value" id="cfg-tree-distance-val">45</span>
                        </div>
                        <div class="setting-item">
                            <label>æ•£å¼€è·ç¦»</label>
                            <input type="range" id="cfg-scatter-distance" min="25" max="80" value="55">
                            <span class="setting-value" id="cfg-scatter-distance-val">55</span>
                        </div>
                        <div class="setting-item">
                            <label>èšç„¦è·ç¦»</label>
                            <input type="range" id="cfg-focus-distance" min="4" max="15" value="8">
                            <span class="setting-value" id="cfg-focus-distance-val">8</span>
                        </div>
                    </div>
                    <!-- æ—‹è½¬è®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">ğŸ”„ æ—‹è½¬</div>
                        <div class="setting-item">
                            <label>æ ‘æ¨¡å¼é€Ÿåº¦</label>
                            <input type="range" id="cfg-tree-rotate" min="0" max="100" value="30">
                            <span class="setting-value" id="cfg-tree-rotate-val">0.3</span>
                        </div>
                        <div class="setting-item">
                            <label>æ•£å¼€é€Ÿåº¦</label>
                            <input type="range" id="cfg-scatter-rotate" min="0" max="50" value="5">
                            <span class="setting-value" id="cfg-scatter-rotate-val">0.05</span>
                        </div>
                    </div>
                    <!-- å‘å…‰è®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">âœ¨ å‘å…‰</div>
                        <div class="setting-item">
                            <label>æ³›å…‰å¼ºåº¦</label>
                            <input type="range" id="cfg-bloom-strength" min="0" max="30" value="15">
                            <span class="setting-value" id="cfg-bloom-strength-val">1.5</span>
                        </div>
                        <div class="setting-item">
                            <label>æ³›å…‰åŠå¾„</label>
                            <input type="range" id="cfg-bloom-radius" min="0" max="20" value="8">
                            <span class="setting-value" id="cfg-bloom-radius-val">0.8</span>
                        </div>
                    </div>
                    <!-- æ˜Ÿæ˜Ÿè®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">â­ æ˜Ÿæ˜Ÿ</div>
                        <div class="setting-item">
                            <label>å‘å…‰å¼ºåº¦</label>
                            <input type="range" id="cfg-star-glow" min="10" max="50" value="25">
                            <span class="setting-value" id="cfg-star-glow-val">2.5</span>
                        </div>
                        <div class="setting-item">
                            <label>é—ªçƒé€Ÿåº¦</label>
                            <input type="range" id="cfg-star-blink" min="1" max="20" value="8">
                            <span class="setting-value" id="cfg-star-blink-val">0.8</span>
                        </div>
                    </div>
                    <!-- é›ªèŠ±è®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">â„ï¸ é›ªèŠ±</div>
                        <div class="setting-item">
                            <label>ä¸‹è½é€Ÿåº¦</label>
                            <input type="range" id="cfg-snow-speed" min="1" max="20" value="8">
                            <span class="setting-value" id="cfg-snow-speed-val">0.08</span>
                        </div>
                        <div class="setting-item">
                            <label>é›ªèŠ±å¤§å°</label>
                            <input type="range" id="cfg-snow-size" min="1" max="10" value="2">
                            <span class="setting-value" id="cfg-snow-size-val">0.2</span>
                        </div>
                    </div>
                    <!-- ç…§ç‰‡è®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">ğŸ–¼ï¸ ç…§ç‰‡</div>
                        <div class="setting-item">
                            <label>æ”¾å¤§å€æ•°</label>
                            <input type="range" id="cfg-photo-scale" min="10" max="50" value="25">
                            <span class="setting-value" id="cfg-photo-scale-val">2.5</span>
                        </div>
                    </div>
                    <!-- éŸ³ä¹è®¾ç½® -->
                    <div class="settings-section">
                        <div class="section-title">ğŸµ éŸ³ä¹</div>
                        <div class="setting-item">
                            <label>èƒŒæ™¯éŸ³ä¹</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="cfg-music-enabled" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>è‡ªåŠ¨æ’­æ”¾</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="cfg-music-autoplay" checked>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <!-- é¢œè‰²è®¾ç½® -->
                    <div class="settings-section settings-section-wide">
                        <div class="section-title">ğŸ¨ é¢œè‰²</div>
                        <div class="color-settings-row">
                            <div class="color-item">
                                <input type="color" id="cfg-ornament-color" value="#88ccff">
                                <label>è£…é¥°çƒ</label>
                            </div>
                            <div class="color-item">
                                <input type="color" id="cfg-box-color" value="#051020">
                                <label>æ–¹å—</label>
                            </div>
                            <div class="color-item">
                                <input type="color" id="cfg-light-color" value="#0066ff">
                                <label>ç¯å…‰</label>
                            </div>
                            <div class="color-item">
                                <input type="color" id="cfg-star-color" value="#ffff00">
                                <label>æ˜Ÿæ˜Ÿ</label>
                            </div>
                            <div class="color-item">
                                <input type="color" id="cfg-snow-color" value="#ffffff">
                                <label>é›ªèŠ±</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-action-btn" id="settings-reset">ğŸ”„ æ¢å¤é»˜è®¤</button>
                <button class="modal-action-btn export" id="settings-apply">âœ“ åº”ç”¨</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // å…¨å±€å˜é‡
        let scene, camera, renderer, composer, bloomPass, mainGroup;
        let clock = new THREE.Clock();
        let particleSystem = [], photoMeshGroup = new THREE.Group();
        let handLandmarker, video, webcamCanvas, webcamCtx;
        let snowSystem;
        let photoDataArray = []; // å­˜å‚¨æ‰€æœ‰ç…§ç‰‡çš„base64æ•°æ®
        let photoIdToMeshMap = new Map(); // ç…§ç‰‡IDåˆ°åœºæ™¯meshçš„æ˜ å°„

        // é…ç½®å‚æ•°ï¼ˆå¯é€šè¿‡è®¾ç½®é¢æ¿è°ƒæ•´ï¼‰
        const CONFIG = {
            treeDistance: 45,
            scatterDistance: 55,
            focusDistance: 8,
            treeRotate: 0.3,
            scatterRotate: 0.1,
            bloomStrength: 1.8,
            bloomRadius: 1,
            starGlow: 3,
            starBlink: 1,
            snowSpeed: 0.03,
            snowSize: 0.2,
            photoScale: 2.5,
            // é¢œè‰²é…ç½®
            ornamentColor: '#88ccff',    // è£…é¥°çƒé¢œè‰²
            boxColor: '#051020',         // æ–¹å—é¢œè‰²
            lightColor: '#0066ff',       // å†…éƒ¨ç¯å…‰é¢œè‰²
            starColor: '#ffff00',        // æ˜Ÿæ˜Ÿé¢œè‰²
            snowColor: '#ffffff'         // é›ªèŠ±é¢œè‰²
        };

        // ========== é¢„ç½®ç…§ç‰‡æ•°æ® ==========
        // ä½¿ç”¨æ–¹æ³•ï¼šå°†å¯¼å‡ºçš„JSONæ–‡ä»¶ä¸­çš„ photos æ•°ç»„å†…å®¹ç²˜è´´åˆ°ä¸‹é¢çš„æ•°ç»„ä¸­
        // æ ¼å¼ç¤ºä¾‹ï¼š["data:image/jpeg;base64,/9j/4AAQ...", "data:image/png;base64,iVBORw0..."]
        const PRESET_PHOTOS = [

  ]
        // ====================================

        // ç¼“å­˜é…ç½®
        const CACHE_CONFIG = {
            maxPhotos: 20,
            maxSizeMB: 50,
            dbName: 'ChristmasTreeDB',
            storeName: 'photos',
            // éŸ³ä¹ç¼“å­˜é…ç½®
            musicStoreName: 'music',
            maxMusicSizeMB: 20
        };

        // IndexedDB å·¥å…·å‡½æ•°
        const PhotoCache = {
            db: null,

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(CACHE_CONFIG.dbName, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(CACHE_CONFIG.storeName)) {
                            const store = db.createObjectStore(CACHE_CONFIG.storeName, { keyPath: 'id' });
                            store.createIndex('timestamp', 'timestamp', { unique: false });
                        }
                    };
                });
            },

            async savePhoto(base64Data) {
                // æ£€æŸ¥æ˜¯å¦è¶…å‡ºé™åˆ¶
                const stats = await this.getStats();
                const newSize = this.getBase64Size(base64Data);

                if (stats.count >= CACHE_CONFIG.maxPhotos) {
                    return { success: false, reason: 'count', message: `å·²è¾¾åˆ°æœ€å¤§ç¼“å­˜æ•°é‡ (${CACHE_CONFIG.maxPhotos} å¼ )ï¼Œè¯·å…ˆåˆ é™¤ä¸€äº›ç…§ç‰‡` };
                }

                if ((stats.totalSize + newSize) / (1024 * 1024) > CACHE_CONFIG.maxSizeMB) {
                    return { success: false, reason: 'size', message: `å·²è¾¾åˆ°æœ€å¤§ç¼“å­˜å¤§å° (${CACHE_CONFIG.maxSizeMB} MB)ï¼Œè¯·å…ˆåˆ é™¤ä¸€äº›ç…§ç‰‡` };
                }

                const photo = {
                    id: 'photo_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    base64: base64Data,
                    timestamp: Date.now(),
                    size: newSize,
                    inScene: true
                };

                return new Promise((resolve) => {
                    const tx = this.db.transaction(CACHE_CONFIG.storeName, 'readwrite');
                    const store = tx.objectStore(CACHE_CONFIG.storeName);
                    const request = store.add(photo);
                    request.onsuccess = () => resolve({ success: true, photo });
                    request.onerror = () => resolve({ success: false, reason: 'db', message: 'ä¿å­˜å¤±è´¥' });
                });
            },

            async getAllPhotos() {
                return new Promise((resolve) => {
                    const tx = this.db.transaction(CACHE_CONFIG.storeName, 'readonly');
                    const store = tx.objectStore(CACHE_CONFIG.storeName);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => resolve([]);
                });
            },

            async deletePhoto(id) {
                return new Promise((resolve) => {
                    const tx = this.db.transaction(CACHE_CONFIG.storeName, 'readwrite');
                    const store = tx.objectStore(CACHE_CONFIG.storeName);
                    const request = store.delete(id);
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => resolve(false);
                });
            },

            async updatePhoto(photo) {
                return new Promise((resolve) => {
                    const tx = this.db.transaction(CACHE_CONFIG.storeName, 'readwrite');
                    const store = tx.objectStore(CACHE_CONFIG.storeName);
                    const request = store.put(photo);
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => resolve(false);
                });
            },

            async clearAll() {
                return new Promise((resolve) => {
                    const tx = this.db.transaction(CACHE_CONFIG.storeName, 'readwrite');
                    const store = tx.objectStore(CACHE_CONFIG.storeName);
                    const request = store.clear();
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => resolve(false);
                });
            },

            async getStats() {
                const photos = await this.getAllPhotos();
                const totalSize = photos.reduce((sum, p) => sum + (p.size || 0), 0);
                return {
                    count: photos.length,
                    totalSize,
                    inSceneCount: photos.filter(p => p.inScene).length
                };
            },

            getBase64Size(base64) {
                // è®¡ç®—base64å­—ç¬¦ä¸²çš„å®é™…å­—èŠ‚å¤§å°
                const base64Length = base64.length - (base64.indexOf(',') + 1);
                const padding = (base64.match(/=+$/) || [''])[0].length;
                return Math.floor((base64Length * 3) / 4) - padding;
            },

            formatSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
            }
        };

        // æè´¨å¯¹è±¡
        const MATERIALS = {};

        // çŠ¶æ€ç®¡ç†
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            camera: {
                targetPos: new THREE.Vector3(0, 2, 50),
                targetLookAt: new THREE.Vector3(0, 0, 0),
                currentLookAt: new THREE.Vector3(0, 0, 0)
            },
            focusTarget: null,
            // è§¦æ‘¸æåˆç¼©æ”¾çŠ¶æ€
            pinch: {
                zoom: 1,
                offsetX: 0,
                offsetY: 0
            },
            // æ‰‹åŠ¿æåˆå¹³ç§»çŠ¶æ€ï¼ˆFOCUSæ¨¡å¼ä¸‹ï¼‰
            handPinch: {
                active: false,
                offsetX: 0,
                offsetY: 0
            }
        };

        // åˆå§‹åŒ– Three.js
        function initThree() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x111111, 0.02);

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.2;
            container.appendChild(renderer.domElement);

            scene.environment = new THREE.PMREMGenerator(renderer).fromScene(new RoomEnvironment(), 0.04).texture;

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        // åˆ›å»ºæè´¨
        function createMaterials() {
            MATERIALS.gold = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                metalness: 1.0,
                roughness: 0.1,
                envMapIntensity: 2.0,
                emissive: 0x002244,
                emissiveIntensity: 0.3
            });

            MATERIALS.green = new THREE.MeshStandardMaterial({
                color: 0x051020,
                metalness: 0.2,
                roughness: 0.8,
                emissive: 0x000510,
                emissiveIntensity: 0.2
            });

            MATERIALS.red = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.3,
                roughness: 0.2,
                clearcoat: 1.0,
                emissive: 0x222222
            });

            MATERIALS.frame = new THREE.MeshBasicMaterial({ color: 0xffffff });

            MATERIALS.star = new THREE.MeshStandardMaterial({
                color: 0xffff00,
                emissive: 0xffaa00,
                emissiveIntensity: 2.5,
                metalness: 0.9,
                roughness: 0.1,
                toneMapped: false
            });

            // ç³–æœçº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#0088ff';
            ctx.beginPath();
            for (let i = -128; i < 256; i += 32) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i + 32, 128);
                ctx.lineTo(i + 16, 128);
                ctx.lineTo(i - 16, 0);
            }
            ctx.fill();
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(3, 3);
            MATERIALS.candy = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.4 });
        }

        // ç¯å…‰å¼•ç”¨
        let innerLight;
        
        // è®¾ç½®ç¯å…‰
        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            innerLight = new THREE.PointLight(0x0066ff, 2, 20);
            innerLight.position.set(0, 5, 0);
            mainGroup.add(innerLight);

            const spot1 = new THREE.SpotLight(0xeefbff, 1500);
            spot1.position.set(30, 40, 40);
            scene.add(spot1);

            const spot2 = new THREE.SpotLight(0x8844ff, 800);
            spot2.position.set(-30, 20, -30);
            scene.add(spot2);

            const fill = new THREE.DirectionalLight(0xaaccff, 0.8);
            fill.position.set(0, 0, 50);
            scene.add(fill);
        }

        // ç²’å­ç±»
        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh;
                this.type = type;
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x;
                this.spinSpeed = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).multiplyScalar(type === 'PHOTO' ? 0.3 : 2.0);

                // æ ‘å½¢ä½ç½®
                const h = 24, halfH = 12;
                let t = Math.pow(Math.random(), 0.8);
                const y = (t * h) - halfH;
                const r = Math.max(0.5, 8 * (1.0 - t)) * (0.8 + Math.random() * 0.4);
                const a = t * 50 * Math.PI + Math.random() * Math.PI;
                this.posTree.set(Math.cos(a) * r, y, Math.sin(a) * r);

                // æ•£å¼€ä½ç½®
                const rs = 12 + Math.random() * 25;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rs * Math.sin(phi) * Math.cos(theta),
                    rs * Math.sin(phi) * Math.sin(theta),
                    rs * Math.cos(phi)
                );
            }

            update(dt, mode) {
                let target = (mode === 'SCATTER' || mode === 'FOCUS') ? this.posScatter : this.posTree;
                this.mesh.position.lerp(target, 2.5 * dt);

                // æœå‘æ§åˆ¶
                if (mode === 'FOCUS' && STATE.focusTarget === this.mesh) {
                    this.mesh.lookAt(camera.position);
                } else if (mode === 'SCATTER') {
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                } else {
                    this.mesh.rotation.set(
                        THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt),
                        this.mesh.rotation.y + 0.5 * dt,
                        THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt)
                    );
                }

                // ç¼©æ”¾æ§åˆ¶
                let s = this.baseScale;
                if ((mode === 'SCATTER' || mode === 'FOCUS') && this.type === 'PHOTO') {
                    s = this.baseScale * CONFIG.photoScale;
                }
                this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt);
            }
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticles() {
            const sphere = new THREE.SphereGeometry(0.5, 32, 32);
            const box = new THREE.BoxGeometry(0.55, 0.55, 0.55);
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0),
                new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0),
                new THREE.Vector3(0.3, 0.4, 0)
            ]);
            const candy = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);

            for (let i = 0; i < 1500; i++) {
                const r = Math.random();
                let mesh, type;

                if (r < 0.4) {
                    mesh = new THREE.Mesh(box, MATERIALS.green);
                    type = 'BOX';
                } else if (r < 0.7) {
                    mesh = new THREE.Mesh(box, MATERIALS.gold);
                    type = 'GOLD_BOX';
                } else if (r < 0.92) {
                    mesh = new THREE.Mesh(sphere, MATERIALS.gold);
                    type = 'GOLD_SPHERE';
                } else if (r < 0.97) {
                    mesh = new THREE.Mesh(sphere, MATERIALS.red);
                    type = 'RED';
                } else {
                    mesh = new THREE.Mesh(candy, MATERIALS.candy);
                    type = 'CANE';
                }

                const s = 0.4 + Math.random() * 0.5;
                mesh.scale.set(s, s, s);
                mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);

                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type));
            }

            // é¡¶éƒ¨äº”è§’æ˜Ÿ
            const starShape = new THREE.Shape();
            const outerRadius = 1.2;
            const innerRadius = 0.48;
            const points = 5;
            
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) starShape.moveTo(x, y);
                else starShape.lineTo(x, y);
            }
            starShape.closePath();
            
            const extrudeSettings = { 
                depth: 0.2, 
                bevelEnabled: true, 
                bevelThickness: 0.1, 
                bevelSize: 0.1, 
                bevelSegments: 3 
            };
            const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
            starGeometry.center();
            
            const topStar = new THREE.Mesh(starGeometry, MATERIALS.star);
            topStar.position.set(0, 13.5, 0);
            // ä¸æ—‹è½¬ï¼Œè®©æ˜Ÿæ˜Ÿæ­£é¢æœå‘ç›¸æœºï¼ˆZè½´æ–¹å‘ï¼‰
            mainGroup.add(topStar);
            
            // æ˜Ÿæ˜Ÿç‚¹å…‰æº
            const starLight = new THREE.PointLight(0xffd700, 2, 10);
            starLight.position.set(0, 13.5, 0);
            mainGroup.add(starLight);
            
            // ä¿å­˜å¼•ç”¨ç”¨äºåŠ¨ç”»
            window.topStar = topStar;
            window.starLight = starLight;

            mainGroup.add(photoMeshGroup);
        }

        // åˆ›å»ºé›ªèŠ±
        function createSnow() {
            const positions = new Float32Array(3000);
            for (let i = 0; i < 3000; i += 3) {
                positions[i] = (Math.random() - 0.5) * 80;
                positions[i + 1] = (Math.random() - 0.5) * 80 + 20;
                positions[i + 2] = (Math.random() - 0.5) * 80;
            }

            snowSystem = new THREE.Points(
                new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(positions, 3)),
                new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.2,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                })
            );
            scene.add(snowSystem);
        }

        // åˆ›å»ºé»˜è®¤ç…§ç‰‡
        let defaultPhotoTexture;
        function createDefaultPhotos() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 15;
            ctx.strokeRect(20, 20, 472, 472);
            ctx.font = '500 60px Times New Roman';
            ctx.fillStyle = '#aaddff';
            ctx.textAlign = 'center';
            ctx.fillText("é¢„ç¥å®¶äººä»¬", 256, 230);
            ctx.fillText("åœ£è¯å¿«ä¹ï¼", 256, 300);

            defaultPhotoTexture = new THREE.CanvasTexture(canvas);
            defaultPhotoTexture.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(defaultPhotoTexture);
        }

        // æ·»åŠ ç…§ç‰‡åˆ°åœºæ™¯
        function addPhotoToScene(texture, base64Data = null, photoId = null) {
            const ar = texture.image.width / texture.image.height;
            const w = ar > 1 ? 1.2 : 1.2 * ar;
            const h = ar > 1 ? 1.2 / ar : 1.2;

            const group = new THREE.Group();
            group.add(new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.1, h + 0.1, 0.05),
                MATERIALS.frame
            ));

            const photoMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                side: THREE.DoubleSide
            });
            const photo = new THREE.Mesh(
                new THREE.PlaneGeometry(w, h),
                photoMaterial
            );
            photo.position.z = 0.04;
            group.add(photo);
            
            // æ·»åŠ èƒŒé¢ç…§ç‰‡ï¼Œè®©ä¸¤é¢éƒ½æ˜¾ç¤ºå›¾ç‰‡
            const photoBack = new THREE.Mesh(
                new THREE.PlaneGeometry(w, h),
                photoMaterial
            );
            photoBack.position.z = -0.04;
            photoBack.rotation.y = Math.PI;
            group.add(photoBack);
            group.scale.setScalar(0.8);

            // å­˜å‚¨photoIdä»¥ä¾¿åç»­ç®¡ç†
            if (photoId) {
                group.userData.photoId = photoId;
                photoIdToMeshMap.set(photoId, group);
            }

            photoMeshGroup.add(group);
            particleSystem.push(new Particle(group, 'PHOTO'));

            // ä¿å­˜base64æ•°æ®
            if (base64Data) {
                photoDataArray.push(base64Data);
            }

            return group;
        }

        // ä»åœºæ™¯ç§»é™¤ç…§ç‰‡
        function removePhotoFromScene(photoId) {
            const mesh = photoIdToMeshMap.get(photoId);
            if (mesh) {
                // ä»ç²’å­ç³»ç»Ÿä¸­ç§»é™¤
                const particleIndex = particleSystem.findIndex(p => p.mesh === mesh);
                if (particleIndex !== -1) {
                    particleSystem.splice(particleIndex, 1);
                }
                // ä»åœºæ™¯ä¸­ç§»é™¤
                photoMeshGroup.remove(mesh);
                // æ¸…ç†æ˜ å°„
                photoIdToMeshMap.delete(photoId);

                // ä»photoDataArrayä¸­ç§»é™¤å¯¹åº”çš„base64æ•°æ®
                // éœ€è¦é€šè¿‡meshçš„userDataæˆ–å…¶ä»–æ–¹å¼æ‰¾åˆ°å¯¹åº”ç´¢å¼•
                return true;
            }
            return false;
        }

        // åå¤„ç†
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,
                0.4,
                0.85
            );
            composer.addPass(bloomPass);
        }

        // UIéšè—çŠ¶æ€
        let uiHidden = false;
        
        // åˆ‡æ¢æ‰€æœ‰UIæ˜¾ç¤º/éšè—
        function toggleAllUI() {
            uiHidden = !uiHidden;
            const newDisplay = uiHidden ? 'none' : '';
            
            // æ ‡é¢˜
            const h1 = document.querySelector('h1');
            if (h1) h1.style.display = newDisplay;
            
            // é¡¶éƒ¨æŒ‰é’®
            const uploadWrapper = document.querySelector('.upload-wrapper');
            if (uploadWrapper) uploadWrapper.style.display = newDisplay;
            
            // æ“ä½œæç¤º
            const tips = document.getElementById('tips');
            if (tips) tips.style.display = newDisplay;
            
            // ç§»åŠ¨ç«¯æ§åˆ¶æŒ‰é’®
            const mobileControls = document.getElementById('mobile-controls');
            if (mobileControls) mobileControls.style.display = uiHidden ? 'none' : 'flex';
            
            // æ‘„åƒå¤´é¢„è§ˆ
            const webcamWrapper = document.getElementById('webcam-wrapper');
            if (webcamWrapper) webcamWrapper.style.display = newDisplay;
        }

        // äº‹ä»¶ç›‘å¬
        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // éŸ³ä¹æ§åˆ¶ - æ‰“å¼€éŸ³ä¹ç®¡ç†æ¨¡æ€æ¡†
            const musicBtn = document.getElementById('music-btn');
            musicBtn.addEventListener('click', () => {
                document.getElementById('music-modal').classList.add('show');
            });

            // é”®ç›˜æ§åˆ¶æ˜¾ç¤ºéšè—
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();

                // Vé”® - åˆ‡æ¢æ‘„åƒå¤´é¢„è§ˆåŒºåŸŸ
                if (key === 'v') {
                    const webcamWrapper = document.getElementById('webcam-wrapper');
                    webcamWrapper.style.display = webcamWrapper.style.display === 'none' ? 'block' : 'none';
                }

                // Fé”® - åˆ‡æ¢å…¨å±
                if (key === 'f') {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.log('å…¨å±åˆ‡æ¢å¤±è´¥:', err);
                        });
                    } else {
                        document.exitFullscreen();
                    }
                }

                // Hé”® - åˆ‡æ¢æ‰€æœ‰UIæ§ä»¶ï¼ˆæ ‡é¢˜ã€æŒ‰é’®ã€æç¤ºã€æ‘„åƒå¤´ï¼‰
                if (key === 'h') {
                    toggleAllUI();
                }

                // é”®ç›˜äº¤äº’ - æ›¿ä»£æ‰‹åŠ¿æ§åˆ¶ï¼ˆé€‚ç”¨äºæ²¡æœ‰æ‘„åƒå¤´çš„ç”µè„‘ï¼‰
                // 1é”®æˆ–Té”® - åœ£è¯æ ‘æ¨¡å¼ï¼ˆå¯¹åº”æ¡æ‹³æ‰‹åŠ¿ï¼‰
                if (key === '1' || key === 't') {
                    STATE.mode = 'TREE';
                    STATE.focusTarget = null;
                }

                // 2é”®æˆ–Sé”® - æ˜Ÿæ²³æ•£å¼€æ¨¡å¼ï¼ˆå¯¹åº”å¼ æ‰‹æ‰‹åŠ¿ï¼‰
                if (key === '2' || key === 's') {
                    STATE.mode = 'SCATTER';
                    STATE.focusTarget = null;
                }

                // 3é”®æˆ–Pé”® - é”å®šç…§ç‰‡æ¨¡å¼ï¼ˆå¯¹åº”æåˆæ‰‹åŠ¿ï¼‰
                if (key === '3' || key === 'p') {
                    STATE.mode = 'FOCUS';
                    // é‡ç½®æ‰€æœ‰åç§»é‡ï¼Œè®©ç…§ç‰‡å±…ä¸­
                    STATE.pinch.offsetX = 0;
                    STATE.pinch.offsetY = 0;
                    STATE.pinch.zoom = 1;
                    STATE.handPinch.offsetX = 0;
                    STATE.handPinch.offsetY = 0;
                    if (camera) {
                        camera.fov = 42;
                        camera.updateProjectionMatrix();
                    }
                    if (!STATE.focusTarget) {
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length) {
                            STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                        }
                    }
                }

                // Né”® - åˆ‡æ¢åˆ°ä¸‹ä¸€å¼ ç…§ç‰‡ï¼ˆåœ¨FOCUSæ¨¡å¼ä¸‹ï¼‰
                if (key === 'n' && STATE.mode === 'FOCUS') {
                    const photos = particleSystem.filter(p => p.type === 'PHOTO');
                    if (photos.length > 1) {
                        const currentIndex = photos.findIndex(p => p.mesh === STATE.focusTarget);
                        const nextIndex = (currentIndex + 1) % photos.length;
                        STATE.focusTarget = photos[nextIndex].mesh;
                    }
                }
            });

            // ========== ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶ ==========
            setupMobileControls();

            // ========== PCç«¯é¼ æ ‡æ§åˆ¶ ==========
            setupMouseControls();
            
            // ========== åŒå‡»éšè—UI ==========
            setupDoubleClickHideUI();

            // ç¼“å­˜ç®¡ç†æ¨¡æ€æ¡†
            setupCacheManagement();
            // å¯¼å‡ºå‘½åå¯¹è¯æ¡†
            setupExportNameModal();
            // éŸ³ä¹ç®¡ç†
            setupMusicManagement();
            // é…ç½®é¢æ¿
            setupSettingsPanel();
        }

        // ç¼“å­˜ç®¡ç†åŠŸèƒ½
        function setupCacheManagement() {
            const modal = document.getElementById('cache-modal');
            const manageBtn = document.getElementById('manage-btn');
            const closeBtn = document.getElementById('modal-close');
            const clearAllBtn = document.getElementById('clear-all-btn');
            const photoGrid = document.getElementById('photo-grid');
            const cacheStats = document.getElementById('cache-stats');

            // æ‰“å¼€æ¨¡æ€æ¡†
            manageBtn.addEventListener('click', () => {
                modal.classList.add('show');
                renderPhotoGrid();
            });

            // å…³é—­æ¨¡æ€æ¡†
            closeBtn.addEventListener('click', () => {
                modal.classList.remove('show');
            });

            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            });

            // æ¸…ç©ºå…¨éƒ¨ç¼“å­˜
            clearAllBtn.addEventListener('click', async () => {
                if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç¼“å­˜çš„ç…§ç‰‡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) return;

                // ä»åœºæ™¯ä¸­ç§»é™¤æ‰€æœ‰ç…§ç‰‡
                const photos = await PhotoCache.getAllPhotos();
                photos.forEach(photo => {
                    removePhotoFromScene(photo.id);
                });

                // æ¸…ç©ºç¼“å­˜
                await PhotoCache.clearAll();
                photoDataArray = [];

                renderPhotoGrid();
                alert('å·²æ¸…ç©ºæ‰€æœ‰ç¼“å­˜ç…§ç‰‡ï¼');
            });

            // ä¸Šä¼ ç…§ç‰‡
            document.getElementById('file-input').addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                let uploadedCount = 0;

                for (const file of files) {
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        const base64 = ev.target.result;

                        // å…ˆä¿å­˜åˆ°ç¼“å­˜
                        const result = await PhotoCache.savePhoto(base64);
                        if (!result.success) {
                            alert(result.message);
                            return;
                        }

                        // åŠ è½½çº¹ç†å¹¶æ·»åŠ åˆ°åœºæ™¯
                        new THREE.TextureLoader().load(base64, (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            addPhotoToScene(texture, base64, result.photo.id);
                            uploadedCount++;

                            // ä¸Šä¼ å®Œæˆååˆ·æ–°ç½‘æ ¼
                            if (uploadedCount === files.length) {
                                renderPhotoGrid();
                            }
                        });
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = ''; // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤ä¸Šä¼ 
            });

            // å¯¼å…¥ç…§ç‰‡
            document.getElementById('import-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (ev) => {
                    try {
                        const importData = JSON.parse(ev.target.result);

                        if (!importData.photos || !Array.isArray(importData.photos)) {
                            alert('æ— æ•ˆçš„ç…§ç‰‡æ•°æ®æ ¼å¼ï¼');
                            return;
                        }

                        let loadedCount = 0;
                        let failedCount = 0;

                        for (const base64 of importData.photos) {
                            // å…ˆä¿å­˜åˆ°ç¼“å­˜
                            const result = await PhotoCache.savePhoto(base64);
                            if (!result.success) {
                                failedCount++;
                                if (failedCount === 1) {
                                    alert(result.message);
                                }
                                continue;
                            }

                            await new Promise((resolve) => {
                                new THREE.TextureLoader().load(base64, (texture) => {
                                    texture.colorSpace = THREE.SRGBColorSpace;
                                    addPhotoToScene(texture, base64, result.photo.id);
                                    loadedCount++;
                                    resolve();
                                });
                            });
                        }

                        renderPhotoGrid();

                        if (loadedCount > 0) {
                            alert(`æˆåŠŸå¯¼å…¥ ${loadedCount} å¼ ç…§ç‰‡ï¼${failedCount > 0 ? `\n${failedCount} å¼ å› ç¼“å­˜é™åˆ¶æœªèƒ½å¯¼å…¥` : ''}`);
                        }
                    } catch (error) {
                        console.error('å¯¼å…¥å¤±è´¥:', error);
                        alert('å¯¼å…¥å¤±è´¥ï¼è¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚');
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
            });

            // å¯¼å‡ºç…§ç‰‡ - æ˜¾ç¤ºå‘½åå¯¹è¯æ¡†
            document.getElementById('export-btn').addEventListener('click', async () => {
                const photos = await PhotoCache.getAllPhotos();
                if (photos.length === 0) {
                    alert('æ²¡æœ‰å¯å¯¼å‡ºçš„ç…§ç‰‡ï¼è¯·å…ˆä¸Šä¼ ç…§ç‰‡ã€‚');
                    return;
                }

                // æ˜¾ç¤ºå‘½åå¯¹è¯æ¡†
                showExportNameModal();
            });

            // æ¸²æŸ“ç…§ç‰‡ç½‘æ ¼
            async function renderPhotoGrid() {
                const photos = await PhotoCache.getAllPhotos();
                const stats = await PhotoCache.getStats();

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                const isWarning = stats.count >= CACHE_CONFIG.maxPhotos * 0.8 ||
                    stats.totalSize / (1024 * 1024) >= CACHE_CONFIG.maxSizeMB * 0.8;

                cacheStats.innerHTML = `å·²ç¼“å­˜ <span class="${isWarning ? 'warning' : 'highlight'}">${stats.count}</span> å¼ ç…§ç‰‡ ` +
                    `(<span class="${isWarning ? 'warning' : 'highlight'}">${PhotoCache.formatSize(stats.totalSize)}</span> / ${CACHE_CONFIG.maxSizeMB} MB)`;

                // æ¸²æŸ“ç…§ç‰‡åˆ—è¡¨
                if (photos.length === 0) {
                    photoGrid.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“·</div>
                            <div>æš‚æ— ç¼“å­˜ç…§ç‰‡</div>
                            <div style="margin-top:10px; font-size:9px;">ä¸Šä¼ ç…§ç‰‡åä¼šè‡ªåŠ¨ç¼“å­˜åˆ°æœ¬åœ°</div>
                        </div>
                    `;
                    return;
                }

                photoGrid.innerHTML = photos.map(photo => {
                    const isInScene = photoIdToMeshMap.has(photo.id);
                    return `
                        <div class="photo-item ${isInScene ? 'in-scene' : ''}" data-id="${photo.id}">
                            <img class="photo-thumb" src="${photo.base64}" alt="ç…§ç‰‡">
                            <div class="photo-info">
                                <div class="photo-size">${PhotoCache.formatSize(photo.size)}</div>
                                <div class="photo-status">${isInScene ? 'âœ“ å·²æ·»åŠ åˆ°åœºæ™¯' : 'æœªæ·»åŠ '}</div>
                                <div class="photo-actions">
                                    ${isInScene ?
                                        `<button class="photo-action-btn remove-scene" data-action="remove" data-id="${photo.id}">ä»åœºæ™¯ç§»é™¤</button>` :
                                        `<button class="photo-action-btn add-scene" data-action="add" data-id="${photo.id}">æ·»åŠ åˆ°åœºæ™¯</button>`
                                    }
                                    <button class="photo-action-btn delete" data-action="delete" data-id="${photo.id}">åˆ é™¤</button>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');

                // ç»‘å®šæŒ‰é’®äº‹ä»¶
                photoGrid.querySelectorAll('.photo-action-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const action = e.target.dataset.action;
                        const photoId = e.target.dataset.id;

                        if (action === 'add') {
                            await addPhotoToSceneFromCache(photoId);
                        } else if (action === 'remove') {
                            await removePhotoAndUpdateCache(photoId);
                        } else if (action === 'delete') {
                            await deletePhotoFromCache(photoId);
                        }

                        renderPhotoGrid();
                    });
                });
            }

            // ä»ç¼“å­˜æ·»åŠ ç…§ç‰‡åˆ°åœºæ™¯
            async function addPhotoToSceneFromCache(photoId) {
                const photos = await PhotoCache.getAllPhotos();
                const photo = photos.find(p => p.id === photoId);
                if (!photo) return;

                await new Promise((resolve) => {
                    new THREE.TextureLoader().load(photo.base64, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        addPhotoToScene(texture, photo.base64, photo.id);
                        resolve();
                    });
                });

                // æ›´æ–°ç¼“å­˜ä¸­çš„çŠ¶æ€
                photo.inScene = true;
                await PhotoCache.updatePhoto(photo);
            }

            // ä»åœºæ™¯ç§»é™¤ç…§ç‰‡å¹¶æ›´æ–°ç¼“å­˜
            async function removePhotoAndUpdateCache(photoId) {
                removePhotoFromScene(photoId);

                // æ›´æ–°ç¼“å­˜ä¸­çš„çŠ¶æ€
                const photos = await PhotoCache.getAllPhotos();
                const photo = photos.find(p => p.id === photoId);
                if (photo) {
                    photo.inScene = false;
                    await PhotoCache.updatePhoto(photo);
                }
            }

            // ä»ç¼“å­˜ä¸­åˆ é™¤ç…§ç‰‡
            async function deletePhotoFromCache(photoId) {
                if (!confirm('ç¡®å®šè¦ä»ç¼“å­˜ä¸­åˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿ')) return;

                // å¦‚æœåœ¨åœºæ™¯ä¸­ï¼Œå…ˆç§»é™¤
                removePhotoFromScene(photoId);

                // ä»ç¼“å­˜ä¸­åˆ é™¤
                await PhotoCache.deletePhoto(photoId);
            }
        }

        // æ˜¾ç¤ºå¯¼å‡ºå‘½åå¯¹è¯æ¡†
        function showExportNameModal() {
            const modal = document.getElementById('export-name-modal');
            const themeInput = document.getElementById('export-theme');
            const customInput = document.getElementById('export-custom');
            const dateInput = document.getElementById('export-date');
            const previewSpan = document.getElementById('filename-preview');

            // è®¾ç½®é»˜è®¤å€¼
            themeInput.value = 'Merry Christmas';
            customInput.value = '';
            dateInput.value = new Date().toISOString().split('T')[0]; // 2024-12-14æ ¼å¼

            // æ›´æ–°é¢„è§ˆ
            function updatePreview() {
                const theme = themeInput.value.trim() || 'Merry Christmas';
                const custom = customInput.value.trim();
                const date = dateInput.value;

                let filename = '';
                if (custom) {
                    filename = custom + '_';
                }
                filename += theme + '_' + date + '.json';

                previewSpan.textContent = filename;
            }

            updatePreview();

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆé˜²æ­¢é‡å¤ç»‘å®šï¼‰
            const newThemeInput = themeInput.cloneNode(true);
            const newCustomInput = customInput.cloneNode(true);
            themeInput.parentNode.replaceChild(newThemeInput, themeInput);
            customInput.parentNode.replaceChild(newCustomInput, customInput);

            // é‡æ–°è·å–å…ƒç´ å¹¶ç»‘å®šäº‹ä»¶
            document.getElementById('export-theme').addEventListener('input', updatePreview);
            document.getElementById('export-custom').addEventListener('input', updatePreview);

            modal.classList.add('show');
        }

        // è®¾ç½®å¯¼å‡ºå‘½åå¯¹è¯æ¡†äº‹ä»¶
        function setupExportNameModal() {
            const modal = document.getElementById('export-name-modal');
            const closeBtn = document.getElementById('export-name-close');
            const cancelBtn = document.getElementById('export-cancel');
            const confirmBtn = document.getElementById('export-confirm');

            // å…³é—­å¯¹è¯æ¡†
            closeBtn.addEventListener('click', () => modal.classList.remove('show'));
            cancelBtn.addEventListener('click', () => modal.classList.remove('show'));
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('show');
            });

            // ç¡®è®¤å¯¼å‡º
            confirmBtn.addEventListener('click', async () => {
                const theme = document.getElementById('export-theme').value.trim() || 'Merry Christmas';
                const custom = document.getElementById('export-custom').value.trim();
                const date = document.getElementById('export-date').value;

                // ç”Ÿæˆæ–‡ä»¶å
                let filename = '';
                if (custom) {
                    filename = custom + '_';
                }
                filename += theme + '_' + date + '.json';

                // æ‰§è¡Œå¯¼å‡º
                const photos = await PhotoCache.getAllPhotos();
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    photos: photos.map(p => p.base64)
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                modal.classList.remove('show');
                alert(`æˆåŠŸå¯¼å‡º ${photos.length} å¼ ç…§ç‰‡ï¼\næ–‡ä»¶å: ${filename}`);
            });
        }

        // ========== é…ç½®é¢æ¿ ==========
        function setupSettingsPanel() {
            const modal = document.getElementById('settings-modal');
            const settingsBtn = document.getElementById('settings-btn');
            const closeBtn = document.getElementById('settings-close');
            const resetBtn = document.getElementById('settings-reset');
            const applyBtn = document.getElementById('settings-apply');

            // æ‰“å¼€é¢æ¿
            settingsBtn.addEventListener('click', () => {
                modal.classList.add('show');
                loadSettingsToUI();
            });

            // å…³é—­é¢æ¿
            closeBtn.addEventListener('click', () => modal.classList.remove('show'));
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('show');
            });

            // æ»‘å—å®æ—¶æ›´æ–°æ˜¾ç¤ºå€¼
            const sliders = {
                'cfg-tree-distance': { config: 'treeDistance', display: v => v },
                'cfg-scatter-distance': { config: 'scatterDistance', display: v => v },
                'cfg-focus-distance': { config: 'focusDistance', display: v => v },
                'cfg-tree-rotate': { config: 'treeRotate', display: v => (v / 100).toFixed(2) },
                'cfg-scatter-rotate': { config: 'scatterRotate', display: v => (v / 100).toFixed(2) },
                'cfg-bloom-strength': { config: 'bloomStrength', display: v => (v / 10).toFixed(1) },
                'cfg-bloom-radius': { config: 'bloomRadius', display: v => (v / 10).toFixed(1) },
                'cfg-star-glow': { config: 'starGlow', display: v => (v / 10).toFixed(1) },
                'cfg-star-blink': { config: 'starBlink', display: v => (v / 10).toFixed(1) },
                'cfg-snow-speed': { config: 'snowSpeed', display: v => (v / 100).toFixed(2) },
                'cfg-snow-size': { config: 'snowSize', display: v => (v / 10).toFixed(1) },
                'cfg-photo-scale': { config: 'photoScale', display: v => (v / 10).toFixed(1) }
            };

            Object.keys(sliders).forEach(id => {
                const slider = document.getElementById(id);
                const valSpan = document.getElementById(id + '-val');
                const cfg = sliders[id];
                
                slider.addEventListener('input', () => {
                    valSpan.textContent = cfg.display(slider.value);
                });
            });

            // åº”ç”¨è®¾ç½®
            applyBtn.addEventListener('click', () => {
                CONFIG.treeDistance = parseInt(document.getElementById('cfg-tree-distance').value);
                CONFIG.scatterDistance = parseInt(document.getElementById('cfg-scatter-distance').value);
                CONFIG.focusDistance = parseInt(document.getElementById('cfg-focus-distance').value);
                CONFIG.treeRotate = parseInt(document.getElementById('cfg-tree-rotate').value) / 100;
                CONFIG.scatterRotate = parseInt(document.getElementById('cfg-scatter-rotate').value) / 100;
                CONFIG.bloomStrength = parseInt(document.getElementById('cfg-bloom-strength').value) / 10;
                CONFIG.bloomRadius = parseInt(document.getElementById('cfg-bloom-radius').value) / 10;
                CONFIG.starGlow = parseInt(document.getElementById('cfg-star-glow').value) / 10;
                CONFIG.starBlink = parseInt(document.getElementById('cfg-star-blink').value) / 10;
                CONFIG.snowSpeed = parseInt(document.getElementById('cfg-snow-speed').value) / 100;
                CONFIG.snowSize = parseInt(document.getElementById('cfg-snow-size').value) / 10;
                CONFIG.photoScale = parseInt(document.getElementById('cfg-photo-scale').value) / 10;
                
                // è·å–é¢œè‰²é…ç½®
                CONFIG.ornamentColor = document.getElementById('cfg-ornament-color').value;
                CONFIG.boxColor = document.getElementById('cfg-box-color').value;
                CONFIG.lightColor = document.getElementById('cfg-light-color').value;
                CONFIG.starColor = document.getElementById('cfg-star-color').value;
                CONFIG.snowColor = document.getElementById('cfg-snow-color').value;

                // åº”ç”¨æ‰€æœ‰é¢œè‰²å’Œæ•ˆæœè®¾ç½®
                applyColorSettings();

                modal.classList.remove('show');
            });

            // æ¢å¤é»˜è®¤
            resetBtn.addEventListener('click', () => {
                CONFIG.treeDistance = 45;
                CONFIG.scatterDistance = 55;
                CONFIG.focusDistance = 8;
                CONFIG.treeRotate = 0.3;
                CONFIG.scatterRotate = 0.1;
                CONFIG.bloomStrength = 1.8;
                CONFIG.bloomRadius = 1;
                CONFIG.starGlow = 3;
                CONFIG.starBlink = 1;
                CONFIG.snowSpeed = 0.03;
                CONFIG.snowSize = 0.2;
                CONFIG.photoScale = 2.5;
                CONFIG.ornamentColor = '#88ccff';
                CONFIG.boxColor = '#051020';
                CONFIG.lightColor = '#0066ff';
                CONFIG.starColor = '#ffff00';
                CONFIG.snowColor = '#ffffff';
                loadSettingsToUI();
                applyColorSettings();
            });
        }
        
        // åº”ç”¨é¢œè‰²è®¾ç½®åˆ°åœºæ™¯
        function applyColorSettings() {
            // åº”ç”¨é›ªèŠ±é¢œè‰²
            if (snowSystem && snowSystem.material) {
                snowSystem.material.size = CONFIG.snowSize;
                snowSystem.material.color.set(CONFIG.snowColor);
                snowSystem.material.needsUpdate = true;
            }
            // åº”ç”¨è£…é¥°çƒé¢œè‰²
            if (MATERIALS.gold) {
                const ornamentHex = parseInt(CONFIG.ornamentColor.replace('#', ''), 16);
                MATERIALS.gold.color.setHex(ornamentHex);
                const emissiveColor = new THREE.Color(ornamentHex).multiplyScalar(0.3);
                MATERIALS.gold.emissive.copy(emissiveColor);
                MATERIALS.gold.emissiveIntensity = 0.5;
                MATERIALS.gold.needsUpdate = true;
            }
            // åº”ç”¨æ–¹å—é¢œè‰²
            if (MATERIALS.green) {
                const boxHex = parseInt(CONFIG.boxColor.replace('#', ''), 16);
                MATERIALS.green.color.setHex(boxHex);
                const boxEmissive = new THREE.Color(boxHex).multiplyScalar(0.1);
                MATERIALS.green.emissive.copy(boxEmissive);
                MATERIALS.green.needsUpdate = true;
            }
            // åº”ç”¨æ˜Ÿæ˜Ÿé¢œè‰²
            if (MATERIALS.star) {
                const starHex = parseInt(CONFIG.starColor.replace('#', ''), 16);
                MATERIALS.star.color.setHex(starHex);
                MATERIALS.star.emissive.setHex(starHex);
                MATERIALS.star.needsUpdate = true;
            }
            // åº”ç”¨ç¯å…‰é¢œè‰²
            if (innerLight) {
                const lightHex = parseInt(CONFIG.lightColor.replace('#', ''), 16);
                innerLight.color.setHex(lightHex);
            }
            // åº”ç”¨æ³›å…‰è®¾ç½®
            if (bloomPass) {
                bloomPass.radius = CONFIG.bloomRadius;
            }
        }

        function loadSettingsToUI() {
            document.getElementById('cfg-tree-distance').value = CONFIG.treeDistance;
            document.getElementById('cfg-tree-distance-val').textContent = CONFIG.treeDistance;
            document.getElementById('cfg-scatter-distance').value = CONFIG.scatterDistance;
            document.getElementById('cfg-scatter-distance-val').textContent = CONFIG.scatterDistance;
            document.getElementById('cfg-focus-distance').value = CONFIG.focusDistance;
            document.getElementById('cfg-focus-distance-val').textContent = CONFIG.focusDistance;
            document.getElementById('cfg-tree-rotate').value = CONFIG.treeRotate * 100;
            document.getElementById('cfg-tree-rotate-val').textContent = CONFIG.treeRotate.toFixed(2);
            document.getElementById('cfg-scatter-rotate').value = CONFIG.scatterRotate * 100;
            document.getElementById('cfg-scatter-rotate-val').textContent = CONFIG.scatterRotate.toFixed(2);
            document.getElementById('cfg-bloom-strength').value = CONFIG.bloomStrength * 10;
            document.getElementById('cfg-bloom-strength-val').textContent = CONFIG.bloomStrength.toFixed(1);
            document.getElementById('cfg-bloom-radius').value = CONFIG.bloomRadius * 10;
            document.getElementById('cfg-bloom-radius-val').textContent = CONFIG.bloomRadius.toFixed(1);
            document.getElementById('cfg-star-glow').value = CONFIG.starGlow * 10;
            document.getElementById('cfg-star-glow-val').textContent = CONFIG.starGlow.toFixed(1);
            document.getElementById('cfg-star-blink').value = CONFIG.starBlink * 10;
            document.getElementById('cfg-star-blink-val').textContent = CONFIG.starBlink.toFixed(1);
            document.getElementById('cfg-snow-speed').value = CONFIG.snowSpeed * 100;
            document.getElementById('cfg-snow-speed-val').textContent = CONFIG.snowSpeed.toFixed(2);
            document.getElementById('cfg-snow-size').value = CONFIG.snowSize * 10;
            document.getElementById('cfg-snow-size-val').textContent = CONFIG.snowSize.toFixed(1);
            document.getElementById('cfg-photo-scale').value = CONFIG.photoScale * 10;
            document.getElementById('cfg-photo-scale-val').textContent = CONFIG.photoScale.toFixed(1);
            // åŠ è½½é¢œè‰²é…ç½®
            document.getElementById('cfg-ornament-color').value = CONFIG.ornamentColor;
            document.getElementById('cfg-box-color').value = CONFIG.boxColor;
            document.getElementById('cfg-light-color').value = CONFIG.lightColor;
            document.getElementById('cfg-star-color').value = CONFIG.starColor;
            document.getElementById('cfg-snow-color').value = CONFIG.snowColor;
        }

        // ========== ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶ ==========
        function setupMobileControls() {
            const mobileTree = document.getElementById('mobile-tree');
            const mobileScatter = document.getElementById('mobile-scatter');
            const mobilePhoto = document.getElementById('mobile-photo');
            const mobileNext = document.getElementById('mobile-next');

            // æ›´æ–°æŒ‰é’®æ¿€æ´»çŠ¶æ€
            function updateMobileButtonState() {
                mobileTree.classList.toggle('active', STATE.mode === 'TREE');
                mobileScatter.classList.toggle('active', STATE.mode === 'SCATTER');
                mobilePhoto.classList.toggle('active', STATE.mode === 'FOCUS');
            }

            // åœ£è¯æ ‘æ¨¡å¼
            mobileTree.addEventListener('click', () => {
                STATE.mode = 'TREE';
                STATE.focusTarget = null;
                updateMobileButtonState();
            });

            // æ˜Ÿæ²³æ•£å¼€æ¨¡å¼
            mobileScatter.addEventListener('click', () => {
                STATE.mode = 'SCATTER';
                STATE.focusTarget = null;
                updateMobileButtonState();
            });

            // é”å®šç…§ç‰‡æ¨¡å¼
            mobilePhoto.addEventListener('click', () => {
                STATE.mode = 'FOCUS';
                // é‡ç½®æ‰€æœ‰åç§»é‡ï¼Œè®©ç…§ç‰‡å±…ä¸­
                STATE.pinch.offsetX = 0;
                STATE.pinch.offsetY = 0;
                STATE.pinch.zoom = 1;
                STATE.handPinch.offsetX = 0;
                STATE.handPinch.offsetY = 0;
                // é‡ç½®ç›¸æœºFOV
                if (camera) {
                    camera.fov = 42;
                    camera.updateProjectionMatrix();
                }
                if (!STATE.focusTarget) {
                    const photos = particleSystem.filter(p => p.type === 'PHOTO');
                    if (photos.length) {
                        STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                    }
                }
                updateMobileButtonState();
            });

            // ä¸‹ä¸€å¼ ç…§ç‰‡
            mobileNext.addEventListener('click', () => {
                const photos = particleSystem.filter(p => p.type === 'PHOTO');
                if (photos.length > 0) {
                    // å¦‚æœä¸åœ¨FOCUSæ¨¡å¼ï¼Œå…ˆåˆ‡æ¢åˆ°FOCUSæ¨¡å¼
                    if (STATE.mode !== 'FOCUS') {
                        STATE.mode = 'FOCUS';
                        // é‡ç½®æ‰€æœ‰åç§»é‡
                        STATE.pinch.offsetX = 0;
                        STATE.pinch.offsetY = 0;
                        STATE.pinch.zoom = 1;
                        STATE.handPinch.offsetX = 0;
                        STATE.handPinch.offsetY = 0;
                        if (camera) {
                            camera.fov = 42;
                            camera.updateProjectionMatrix();
                        }
                    }
                    if (photos.length > 1 && STATE.focusTarget) {
                        const currentIndex = photos.findIndex(p => p.mesh === STATE.focusTarget);
                        const nextIndex = (currentIndex + 1) % photos.length;
                        STATE.focusTarget = photos[nextIndex].mesh;
                    } else if (!STATE.focusTarget) {
                        STATE.focusTarget = photos[0].mesh;
                    }
                    updateMobileButtonState();
                }
            });

            // è§¦æ‘¸æ»‘åŠ¨æ§åˆ¶
            let touchStartX = 0;
            let touchStartY = 0;
            const canvas = document.getElementById('canvas-container');
            const FOCUS_PAN_SENSITIVITY = 0.015; // FOCUSæ¨¡å¼ä¸‹å¹³ç§»çµæ•åº¦

            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                // å•æŒ‡æ»‘åŠ¨
                if (e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;
                    
                    if (STATE.mode === 'FOCUS') {
                        // FOCUSæ¨¡å¼ä¸‹ï¼šå•æŒ‡æ‹–åŠ¨ç§»åŠ¨ç…§ç‰‡
                        STATE.handPinch.offsetX -= deltaX * FOCUS_PAN_SENSITIVITY;
                        STATE.handPinch.offsetY += deltaY * FOCUS_PAN_SENSITIVITY;
                        
                        // é™åˆ¶å¹³ç§»èŒƒå›´
                        const maxOffset = 5;
                        STATE.handPinch.offsetX = Math.max(-maxOffset, Math.min(maxOffset, STATE.handPinch.offsetX));
                        STATE.handPinch.offsetY = Math.max(-maxOffset, Math.min(maxOffset, STATE.handPinch.offsetY));
                    } else {
                        // å…¶ä»–æ¨¡å¼ï¼šå•æŒ‡æ»‘åŠ¨æ—‹è½¬
                        STATE.rotation.y += deltaX * 0.005;
                        STATE.rotation.x += deltaY * 0.002;
                        STATE.rotation.x = Math.max(-0.5, Math.min(0.5, STATE.rotation.x));
                    }
                    
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            }, { passive: true });

            // åŒæŒ‡ç¼©æ”¾åŠŸèƒ½
            let initialPinchDistance = 0;
            let isPinching = false;
            const MIN_ZOOM = 0.5;
            const MAX_ZOOM = 3;

            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    isPinching = true;
                    initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && isPinching) {
                    // è®¡ç®—å½“å‰åŒæŒ‡è·ç¦»
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                    if (initialPinchDistance > 0) {
                        const scale = currentDistance / initialPinchDistance;
                        STATE.pinch.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, STATE.pinch.zoom * (1 + (scale - 1) * 0.05)));
                        initialPinchDistance = currentDistance;
                    }
                    
                    // åº”ç”¨ç¼©æ”¾åˆ°ç›¸æœºFOV
                    const baseFov = 42;
                    camera.fov = baseFov / STATE.pinch.zoom;
                    camera.updateProjectionMatrix();
                }
            }, { passive: true });

            canvas.addEventListener('touchend', (e) => {
                if (e.touches.length < 2) {
                    isPinching = false;
                }
            }, { passive: true });

            // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
            updateMobileButtonState();
        }

        // ========== PCç«¯é¼ æ ‡æ§åˆ¶ ==========
        function setupMouseControls() {
            const canvas = document.getElementById('canvas-container');
            let isRightMouseDown = false;
            let isLeftMouseDown = false;
            let mouseStartX = 0;
            let mouseStartY = 0;
            const MIN_ZOOM = 0.5;
            const MAX_ZOOM = 3;
            const PAN_SENSITIVITY = 0.01;

            // ç¦ç”¨å³é”®èœå•
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // é¼ æ ‡æŒ‰ä¸‹
            canvas.addEventListener('mousedown', (e) => {
                mouseStartX = e.clientX;
                mouseStartY = e.clientY;
                if (e.button === 0) { // å·¦é”®
                    isLeftMouseDown = true;
                    canvas.style.cursor = 'grab';
                } else if (e.button === 2) { // å³é”®
                    isRightMouseDown = true;
                    canvas.style.cursor = 'move';
                }
            });

            // é¼ æ ‡ç§»åŠ¨ - å·¦é”®æ—‹è½¬/å¹³ç§»ï¼Œå³é”®å¹³ç§»
            canvas.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - mouseStartX;
                const deltaY = e.clientY - mouseStartY;
                
                if (isLeftMouseDown) {
                    if (STATE.mode === 'FOCUS') {
                        // FOCUSæ¨¡å¼ä¸‹å·¦é”®æ‹–åŠ¨å¹³ç§»ç…§ç‰‡
                        STATE.handPinch.offsetX -= deltaX * PAN_SENSITIVITY;
                        STATE.handPinch.offsetY += deltaY * PAN_SENSITIVITY;
                        
                        const maxOffset = 5;
                        STATE.handPinch.offsetX = Math.max(-maxOffset, Math.min(maxOffset, STATE.handPinch.offsetX));
                        STATE.handPinch.offsetY = Math.max(-maxOffset, Math.min(maxOffset, STATE.handPinch.offsetY));
                    } else {
                        // å…¶ä»–æ¨¡å¼å·¦é”®æ‹–åŠ¨æ—‹è½¬
                        STATE.rotation.y += deltaX * 0.005;
                        STATE.rotation.x += deltaY * 0.002;
                        STATE.rotation.x = Math.max(-0.5, Math.min(0.5, STATE.rotation.x));
                    }
                    mouseStartX = e.clientX;
                    mouseStartY = e.clientY;
                } else if (isRightMouseDown) {
                    // å³é”®æ‹–åŠ¨å¹³ç§»ï¼ˆéFOCUSæ¨¡å¼ï¼‰
                    STATE.pinch.offsetX += deltaX * PAN_SENSITIVITY / STATE.pinch.zoom;
                    STATE.pinch.offsetY -= deltaY * PAN_SENSITIVITY / STATE.pinch.zoom;
                    
                    // é™åˆ¶å¹³ç§»èŒƒå›´
                    const maxOffset = 10 / STATE.pinch.zoom;
                    STATE.pinch.offsetX = Math.max(-maxOffset, Math.min(maxOffset, STATE.pinch.offsetX));
                    STATE.pinch.offsetY = Math.max(-maxOffset, Math.min(maxOffset, STATE.pinch.offsetY));
                    
                    mouseStartX = e.clientX;
                    mouseStartY = e.clientY;
                }
            });

            // é¼ æ ‡é‡Šæ”¾
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isLeftMouseDown = false;
                    canvas.style.cursor = 'default';
                } else if (e.button === 2) {
                    isRightMouseDown = false;
                    canvas.style.cursor = 'default';
                }
            });

            // é¼ æ ‡ç¦»å¼€ç”»å¸ƒ
            canvas.addEventListener('mouseleave', () => {
                isRightMouseDown = false;
                isLeftMouseDown = false;
                canvas.style.cursor = 'default';
            });

            // æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                // æ ¹æ®æ»šè½®æ–¹å‘è°ƒæ•´ç¼©æ”¾
                const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                STATE.pinch.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, STATE.pinch.zoom + zoomDelta));
                
                // åº”ç”¨ç¼©æ”¾åˆ°ç›¸æœºFOV
                const baseFov = 42;
                camera.fov = baseFov / STATE.pinch.zoom;
                camera.updateProjectionMatrix();
            }, { passive: false });

        }
        
        // ========== åŒå‡»éšè—UI ==========
        function setupDoubleClickHideUI() {
            const canvas = document.getElementById('canvas-container');
            
            // PCç«¯åŒå‡»éšè—UI
            canvas.addEventListener('dblclick', (e) => {
                // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯canvasåŒºåŸŸï¼ˆä¸æ˜¯æŒ‰é’®ç­‰UIå…ƒç´ ï¼‰
                if (e.target === canvas || e.target.tagName === 'CANVAS') {
                    toggleAllUI();
                }
            });
            
            // ç§»åŠ¨ç«¯åŒå‡»éšè—UI
            let lastTouchTime = 0;
            let touchCount = 0;
            const DOUBLE_TAP_DELAY = 300; // åŒå‡»é—´éš”æ—¶é—´
            
            canvas.addEventListener('touchend', (e) => {
                // åªå¤„ç†å•æŒ‡è§¦æ‘¸
                if (e.changedTouches.length !== 1) return;
                
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTouchTime;
                
                if (tapLength < DOUBLE_TAP_DELAY && tapLength > 0) {
                    // åŒå‡»æ£€æµ‹æˆåŠŸ
                    touchCount++;
                    if (touchCount >= 1) {
                        toggleAllUI();
                        touchCount = 0;
                        e.preventDefault();
                    }
                } else {
                    touchCount = 0;
                }
                
                lastTouchTime = currentTime;
            }, { passive: false });
        }

        // éŸ³ä¹ç®¡ç†åŠŸèƒ½
        const MUSIC_PLAYLIST = [
            { name: 'EXO - ì²« ëˆˆ The First Snow', src: 'EXO - ì²« ëˆˆ The First Snow.mp3' },
            { name: 'Christmas Background', src: 'christmas-christmas-background-music-449476.mp3' },
            { name: 'We Wish You A Merry Christmas', src: 'we-wish-you-a-merry-christmas-444573.mp3' }
        ];
        
        let currentTrackIndex = 0;
        let currentMusicName = MUSIC_PLAYLIST[0].name;
        let musicEnabled = true;
        let musicAutoplay = true;
        let targetVolume = 0.5;
        let isFading = false;
        const FADE_DURATION = 1500; // æ·¡å…¥æ·¡å‡ºæ—¶é•¿(ms)

        function setupMusicManagement() {
            const modal = document.getElementById('music-modal');
            const bgMusic = document.getElementById('bg-music');
            const mainMusicBtn = document.getElementById('music-btn');
            const visualizer = document.getElementById('music-visualizer');

            // åˆå§‹åŒ–ç¬¬ä¸€é¦–æ­Œ
            bgMusic.src = MUSIC_PLAYLIST[0].src;
            bgMusic.volume = 0;

            // æ¨¡æ€æ¡†å…³é—­æŒ‰é’®
            document.getElementById('music-modal-close').addEventListener('click', () => modal.classList.remove('show'));
            document.getElementById('music-close-btn').addEventListener('click', () => modal.classList.remove('show'));
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('show');
            });

            // Tabåˆ‡æ¢
            const tabs = document.querySelectorAll('.music-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    const tabId = tab.dataset.tab;
                    document.getElementById('tab-url').style.display = tabId === 'url' ? 'block' : 'none';
                    document.getElementById('tab-upload').style.display = tabId === 'upload' ? 'block' : 'none';
                });
            });

            // åº”ç”¨URLæŒ‰é’®
            document.getElementById('apply-url-btn').addEventListener('click', () => {
                const urlInput = document.getElementById('music-url-input');
                const url = urlInput.value.trim();
                if (!url) { alert('è¯·è¾“å…¥éŸ³ä¹é“¾æ¥ï¼'); return; }
                try { new URL(url); } catch { alert('è¯·è¾“å…¥æœ‰æ•ˆçš„URLé“¾æ¥ï¼'); return; }
                applyMusicSource(url, getFileNameFromUrl(url));
            });

            // éŸ³é¢‘æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ
            const uploadArea = document.getElementById('music-upload-area');
            const fileInput = document.getElementById('music-file-input');
            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
            uploadArea.addEventListener('dragleave', () => { uploadArea.classList.remove('dragover'); });
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('audio/')) handleAudioFile(file);
                else alert('è¯·ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶ï¼');
            });
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleAudioFile(file);
                e.target.value = '';
            });

            function handleAudioFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => applyMusicSource(e.target.result, file.name);
                reader.readAsDataURL(file);
            }

            function applyMusicSource(src, name) {
                fadeOut(() => {
                    bgMusic.src = src;
                    currentMusicName = name || 'è‡ªå®šä¹‰éŸ³ä¹';
                    updateMusicInfo();
                    if (musicEnabled) fadeIn();
                });
                alert(`å·²åº”ç”¨éŸ³ä¹: ${name}`);
            }

            // æ·¡å…¥æ•ˆæœ
            function fadeIn(callback) {
                if (isFading) return;
                isFading = true;
                bgMusic.volume = 0;
                bgMusic.play().catch(err => { console.log('æ’­æ”¾å¤±è´¥:', err); isFading = false; return; });
                
                const startTime = Date.now();
                const fade = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / FADE_DURATION, 1);
                    bgMusic.volume = progress * targetVolume;
                    if (progress < 1) requestAnimationFrame(fade);
                    else { isFading = false; if (callback) callback(); }
                };
                fade();
            }

            // æ·¡å‡ºæ•ˆæœ
            function fadeOut(callback) {
                if (bgMusic.paused || bgMusic.volume === 0) { if (callback) callback(); return; }
                isFading = true;
                const startVolume = bgMusic.volume;
                const startTime = Date.now();
                const fade = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / FADE_DURATION, 1);
                    bgMusic.volume = startVolume * (1 - progress);
                    if (progress < 1) requestAnimationFrame(fade);
                    else { bgMusic.pause(); isFading = false; if (callback) callback(); }
                };
                fade();
            }

            // æ’­æ”¾ä¸‹ä¸€é¦–
            function playNext() {
                currentTrackIndex = (currentTrackIndex + 1) % MUSIC_PLAYLIST.length;
                const track = MUSIC_PLAYLIST[currentTrackIndex];
                fadeOut(() => {
                    bgMusic.src = track.src;
                    currentMusicName = track.name;
                    updateMusicInfo();
                    if (musicEnabled) fadeIn();
                });
            }

            // æ­Œæ›²ç»“æŸæ—¶è‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€é¦–
            bgMusic.addEventListener('ended', () => {
                if (musicEnabled) playNext();
            });

            // æ’­æ”¾/æš‚åœæ§åˆ¶
            const playBtn = document.getElementById('music-play-btn');
            const pauseBtn = document.getElementById('music-pause-btn');

            playBtn.addEventListener('click', () => {
                if (!musicEnabled) return;
                fadeIn();
            });

            pauseBtn.addEventListener('click', () => {
                fadeOut();
            });

            // ä¸‹ä¸€é¦–æŒ‰é’®
            document.getElementById('music-next-btn').addEventListener('click', () => {
                playNext();
            });

            // ç›‘å¬éŸ³é¢‘çŠ¶æ€å˜åŒ–
            bgMusic.addEventListener('play', () => updatePlayState(true));
            bgMusic.addEventListener('pause', () => updatePlayState(false));

            function updatePlayState(playing) {
                if (playing) {
                    playBtn.classList.add('playing');
                    mainMusicBtn.classList.add('active');
                    visualizer.classList.remove('paused');
                } else {
                    playBtn.classList.remove('playing');
                    mainMusicBtn.classList.remove('active');
                    visualizer.classList.add('paused');
                }
            }

            // å·¦ä¸‹è§’éŸ³ä¹åŠ¨æ•ˆç‚¹å‡»æ§åˆ¶
            visualizer.addEventListener('click', () => {
                if (!musicEnabled) return;
                if (bgMusic.paused) fadeIn();
                else fadeOut();
            });

            // éŸ³é‡æ§åˆ¶
            const volumeSlider = document.getElementById('music-volume');
            const volumeValue = document.getElementById('volume-value');

            volumeSlider.addEventListener('input', () => {
                targetVolume = volumeSlider.value / 100;
                if (!bgMusic.paused && !isFading) bgMusic.volume = targetVolume;
                volumeValue.textContent = volumeSlider.value + '%';
                localStorage.setItem('musicVolume', volumeSlider.value);
            });

            // æ¢å¤é»˜è®¤
            document.getElementById('music-reset-btn').addEventListener('click', () => {
                if (confirm('ç¡®å®šè¦æ¢å¤é»˜è®¤æ’­æ”¾åˆ—è¡¨å—ï¼Ÿ')) {
                    currentTrackIndex = 0;
                    const track = MUSIC_PLAYLIST[0];
                    fadeOut(() => {
                        bgMusic.src = track.src;
                        currentMusicName = track.name;
                        updateMusicInfo();
                        document.getElementById('music-url-input').value = '';
                        localStorage.removeItem('musicSrc');
                        localStorage.removeItem('musicName');
                        if (musicEnabled) fadeIn();
                    });
                    alert('å·²æ¢å¤é»˜è®¤æ’­æ”¾åˆ—è¡¨');
                }
            });

            function updateMusicInfo() {
                document.getElementById('current-music-name').textContent = currentMusicName;
            }

            function getFileNameFromUrl(url) {
                try {
                    const pathname = new URL(url).pathname;
                    const filename = pathname.split('/').pop();
                    return decodeURIComponent(filename) || 'åœ¨çº¿éŸ³ä¹';
                } catch { return 'åœ¨çº¿éŸ³ä¹'; }
            }

            // è®¾ç½®é¢æ¿ä¸­çš„éŸ³ä¹å¼€å…³
            const musicEnabledCheckbox = document.getElementById('cfg-music-enabled');
            const musicAutoplayCheckbox = document.getElementById('cfg-music-autoplay');

            if (musicEnabledCheckbox) {
                musicEnabledCheckbox.addEventListener('change', () => {
                    musicEnabled = musicEnabledCheckbox.checked;
                    localStorage.setItem('musicEnabled', musicEnabled);
                    if (!musicEnabled) {
                        fadeOut();
                        visualizer.style.display = 'none';
                    } else {
                        visualizer.style.display = 'flex';
                        if (musicAutoplay) fadeIn();
                    }
                });
            }

            if (musicAutoplayCheckbox) {
                musicAutoplayCheckbox.addEventListener('change', () => {
                    musicAutoplay = musicAutoplayCheckbox.checked;
                    localStorage.setItem('musicAutoplay', musicAutoplay);
                });
            }

            // æ¢å¤è®¾ç½®
            function restoreMusicSettings() {
                const savedVolume = localStorage.getItem('musicVolume');
                const savedEnabled = localStorage.getItem('musicEnabled');
                const savedAutoplay = localStorage.getItem('musicAutoplay');

                if (savedVolume) {
                    volumeSlider.value = savedVolume;
                    targetVolume = savedVolume / 100;
                    volumeValue.textContent = savedVolume + '%';
                } else {
                    targetVolume = 0.5;
                }

                if (savedEnabled !== null) {
                    musicEnabled = savedEnabled === 'true';
                    if (musicEnabledCheckbox) musicEnabledCheckbox.checked = musicEnabled;
                }

                if (savedAutoplay !== null) {
                    musicAutoplay = savedAutoplay === 'true';
                    if (musicAutoplayCheckbox) musicAutoplayCheckbox.checked = musicAutoplay;
                }

                if (!musicEnabled) {
                    visualizer.style.display = 'none';
                }

                updateMusicInfo();
            }

            restoreMusicSettings();

            // ç”¨æˆ·äº¤äº’åè‡ªåŠ¨æ’­æ”¾
            const startMusic = () => {
                if (musicEnabled && musicAutoplay && bgMusic.paused) {
                    fadeIn();
                }
                document.removeEventListener('click', startMusic);
                document.removeEventListener('touchstart', startMusic);
            };
            document.addEventListener('click', startMusic);
            document.addEventListener('touchstart', startMusic);
        }

        // ä»ç¼“å­˜æ¢å¤ç…§ç‰‡åˆ°åœºæ™¯
        async function restorePhotosFromCache() {
            const photos = await PhotoCache.getAllPhotos();

            for (const photo of photos) {
                if (photo.inScene) {
                    await new Promise((resolve) => {
                        new THREE.TextureLoader().load(photo.base64, (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            addPhotoToScene(texture, photo.base64, photo.id);
                            resolve();
                        });
                    });
                }
            }

            if (photos.length > 0) {
                console.log(`å·²ä»ç¼“å­˜æ¢å¤ ${photos.filter(p => p.inScene).length} å¼ ç…§ç‰‡`);
            }
        }

        // åŠ è½½é¢„ç½®ç…§ç‰‡ï¼ˆæºä»£ç ä¸­åµŒå…¥çš„ç…§ç‰‡ï¼‰
        async function loadPresetPhotos() {
            if (!PRESET_PHOTOS || PRESET_PHOTOS.length === 0) {
                return;
            }

            console.log(`æ­£åœ¨åŠ è½½ ${PRESET_PHOTOS.length} å¼ é¢„ç½®ç…§ç‰‡...`);
            let loadedCount = 0;

            for (const base64 of PRESET_PHOTOS) {
                if (!base64 || !base64.startsWith('data:image')) {
                    continue;
                }

                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨äºç¼“å­˜ä¸­ï¼ˆé€šè¿‡æ¯”è¾ƒbase64çš„å‰100ä¸ªå­—ç¬¦æ¥åˆ¤æ–­ï¼‰
                const photos = await PhotoCache.getAllPhotos();
                const exists = photos.some(p => p.base64.substring(0, 100) === base64.substring(0, 100));

                if (!exists) {
                    // ä¿å­˜åˆ°ç¼“å­˜
                    const result = await PhotoCache.savePhoto(base64);
                    if (result.success) {
                        await new Promise((resolve) => {
                            new THREE.TextureLoader().load(base64, (texture) => {
                                texture.colorSpace = THREE.SRGBColorSpace;
                                addPhotoToScene(texture, base64, result.photo.id);
                                loadedCount++;
                                resolve();
                            });
                        });
                    }
                }
            }

            if (loadedCount > 0) {
                console.log(`å·²åŠ è½½ ${loadedCount} å¼ é¢„ç½®ç…§ç‰‡`);
            }
        }

        // åˆå§‹åŒ– MediaPipe æ‰‹åŠ¿è¯†åˆ«
        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://testingcf.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );

                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://testingcf.jsdelivr.net/gh/CJcrazycool/mediapipe-mirror@main/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                if (navigator.mediaDevices?.getUserMedia) {
                    video = document.getElementById('webcam');
                    video.srcObject = await navigator.mediaDevices.getUserMedia({ video: true });
                    webcamCanvas = document.getElementById('webcam-preview');
                    webcamCtx = webcamCanvas.getContext('2d');
                    video.addEventListener("loadeddata", predictWebcam);
                }
            } catch (error) {
                console.warn('æ‘„åƒå¤´æˆ–æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥ï¼Œå°†ç¦ç”¨æ‰‹åŠ¿åŠŸèƒ½:', error.message);
                // éšè—æ‘„åƒå¤´é¢„è§ˆåŒºåŸŸ
                const webcamWrapper = document.getElementById('webcam-wrapper');
                if (webcamWrapper) webcamWrapper.style.display = 'none';
            }
        }

        // æ‰‹åŠ¿è¯†åˆ«å¾ªç¯
        let lastTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastTime && handLandmarker) {
                lastTime = video.currentTime;
                webcamCanvas.width = video.videoWidth;
                webcamCanvas.height = video.videoHeight;

                webcamCtx.save();
                webcamCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
                webcamCtx.drawImage(video, 0, 0);

                const result = handLandmarker.detectForVideo(video, performance.now());

                if (result.landmarks.length) {
                    STATE.hand.detected = true;
                    STATE.hand.x = (result.landmarks[0][9].x - 0.5) * 2;
                    STATE.hand.y = (result.landmarks[0][9].y - 0.5) * 2;

                    const wrist = result.landmarks[0][0];
                    const index = result.landmarks[0][8];
                    const thumb = result.landmarks[0][4];

                    const indexDist = Math.hypot(index.x - wrist.x, index.y - wrist.y);
                    const thumbDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                    const isFist = indexDist < 0.3 && thumbDist > 0.08;
                    const isOpen = indexDist > 0.4;
                    const isPinch = thumbDist < 0.08;

                    // æ‰‹åŠ¿é€»è¾‘
                    if (isPinch && (STATE.mode === 'SCATTER' || STATE.mode === 'FOCUS')) {
                        STATE.mode = 'FOCUS';
                        STATE.handPinch.active = true;
                        
                        // åœ¨FOCUSæ¨¡å¼ä¸‹ï¼Œæåˆæ‰‹åŠ¿çš„ä½ç½®æ§åˆ¶é•œå¤´å¹³ç§»
                        // ä½¿ç”¨æåˆç‚¹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡ä¸­ç‚¹ï¼‰çš„ä½ç½®
                        const pinchX = (thumb.x + index.x) / 2;
                        const pinchY = (thumb.y + index.y) / 2;
                        
                        // å°†æ‰‹çš„ä½ç½®æ˜ å°„åˆ°é•œå¤´åç§»ï¼ˆèŒƒå›´çº¦ -2 åˆ° 2ï¼‰
                        // æ‰‹åœ¨ç”»é¢ä¸­å¿ƒæ—¶åç§»ä¸º0ï¼Œå‘è¾¹ç¼˜ç§»åŠ¨æ—¶åç§»å¢åŠ 
                        const targetOffsetX = (pinchX - 0.5) * -4; // åå‘ï¼Œæ‰‹å‘å³é•œå¤´å‘å·¦
                        const targetOffsetY = (pinchY - 0.5) * -3; // åå‘ï¼Œæ‰‹å‘ä¸‹é•œå¤´å‘ä¸Š
                        
                        // å¹³æ»‘è¿‡æ¸¡åˆ°ç›®æ ‡åç§»
                        STATE.handPinch.offsetX += (targetOffsetX - STATE.handPinch.offsetX) * 0.1;
                        STATE.handPinch.offsetY += (targetOffsetY - STATE.handPinch.offsetY) * 0.1;
                        
                        if (!STATE.focusTarget) {
                            const photos = particleSystem.filter(p => p.type === 'PHOTO');
                            if (photos.length) {
                                STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh;
                            }
                        }
                    } else if (isFist) {
                        STATE.mode = 'TREE';
                        STATE.focusTarget = null;
                        STATE.handPinch.active = false;
                        // é‡ç½®æ‰‹åŠ¿å¹³ç§»åç§»
                        STATE.handPinch.offsetX = 0;
                        STATE.handPinch.offsetY = 0;
                    } else if (isOpen) {
                        STATE.mode = 'SCATTER';
                        STATE.focusTarget = null;
                        STATE.handPinch.active = false;
                        // é‡ç½®æ‰‹åŠ¿å¹³ç§»åç§»
                        STATE.handPinch.offsetX = 0;
                        STATE.handPinch.offsetY = 0;
                    }

                    // ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶
                    const landmarks = result.landmarks[0];
                    const connections = [
                        [0,1],[1,2],[2,3],[3,4],
                        [0,5],[5,6],[6,7],[7,8],
                        [0,9],[9,10],[10,11],[11,12],
                        [0,13],[13,14],[14,15],[15,16],
                        [0,17],[17,18],[18,19],[19,20],
                        [5,9],[9,13],[13,17]
                    ];

                    webcamCtx.shadowBlur = 8;
                    webcamCtx.shadowColor = '#00ffcc';
                    webcamCtx.lineWidth = 3;
                    webcamCtx.strokeStyle = 'rgba(0, 255, 204, 0.9)';

                    for (let [s, e] of connections) {
                        webcamCtx.beginPath();
                        webcamCtx.moveTo(
                            landmarks[s].x * webcamCanvas.width,
                            landmarks[s].y * webcamCanvas.height
                        );
                        webcamCtx.lineTo(
                            landmarks[e].x * webcamCanvas.width,
                            landmarks[e].y * webcamCanvas.height
                        );
                        webcamCtx.stroke();
                    }

                    // ç»˜åˆ¶å…³é”®èŠ‚ç‚¹
                    webcamCtx.fillStyle = 'rgba(0, 255, 204, 0.8)';
                    for (let i of [0, 4, 8, 12, 16, 20]) {
                        webcamCtx.beginPath();
                        webcamCtx.arc(
                            landmarks[i].x * webcamCanvas.width,
                            landmarks[i].y * webcamCanvas.height,
                            4,
                            0,
                            2 * Math.PI
                        );
                        webcamCtx.fill();
                    }

                    webcamCtx.shadowBlur = 0;
                }

                webcamCtx.restore();
            }
            requestAnimationFrame(predictWebcam);
        }
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // FOCUSæ¨¡å¼ - ç…§ç‰‡å±…ä¸­æ˜¾ç¤º
            if (STATE.mode === 'FOCUS' && STATE.focusTarget) {
                bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 0.6, 5 * dt);
                
                // è·å–ç›®æ ‡ç…§ç‰‡çš„ä¸–ç•Œåæ ‡
                const targetWorldPos = new THREE.Vector3();
                STATE.focusTarget.getWorldPosition(targetWorldPos);
                
                // ç›¸æœºè·ç¦»
                const cameraDistance = CONFIG.focusDistance;
                
                // åœ¨FOCUSæ¨¡å¼ä¸‹ï¼Œåº”ç”¨å¹³ç§»åç§»ï¼ˆæ”¯æŒæ‰‹åŠ¿æåˆå’Œè§¦æ‘¸æ‹–åŠ¨ï¼‰
                const handOffsetX = STATE.handPinch.offsetX;
                const handOffsetY = STATE.handPinch.offsetY;
                
                // ç›¸æœºä½ç½®ï¼šä»æ­£å‰æ–¹çœ‹å‘ç…§ç‰‡ï¼ŒZè½´å›ºå®š
                STATE.camera.targetPos.set(
                    targetWorldPos.x + handOffsetX, 
                    targetWorldPos.y + handOffsetY, 
                    targetWorldPos.z + cameraDistance
                );
                STATE.camera.targetLookAt.set(
                    targetWorldPos.x + handOffsetX,
                    targetWorldPos.y + handOffsetY,
                    targetWorldPos.z
                );
            } else {
                // éFOCUSæ¨¡å¼
                bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, CONFIG.bloomStrength, 2 * dt);
                
                // ç§»åŠ¨ç«¯ç›¸æœºè·ç¦»æ›´è¿œï¼Œè®©åœ£è¯æ ‘æ˜¾ç¤ºæ›´å°
                const isMobile = window.innerWidth <= 768;
                const mobileMultiplier = isMobile ? 1.6 : 1;
                let camZ = STATE.mode === 'SCATTER' ? CONFIG.scatterDistance * mobileMultiplier : CONFIG.treeDistance * mobileMultiplier;
                
                // ä¿ç•™æåˆå¹³ç§»çš„åç§»é‡
                STATE.camera.targetPos.set(STATE.pinch.offsetX, 2 + STATE.pinch.offsetY, camZ);
                STATE.camera.targetLookAt.set(STATE.pinch.offsetX, STATE.pinch.offsetY, 0);
            }
            
            // ç›¸æœºå¹³æ»‘ç§»åŠ¨
            camera.position.lerp(STATE.camera.targetPos, 1 * dt);
            STATE.camera.currentLookAt.lerp(STATE.camera.targetLookAt, 1.5 * dt);
            camera.lookAt(STATE.camera.currentLookAt);
            
            // æ—‹è½¬æ§åˆ¶
            if (STATE.mode !== 'FOCUS') {
                if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                    STATE.rotation.x += (STATE.hand.y * 0.8 - STATE.rotation.x) * 1 * dt;
                    STATE.rotation.y += (STATE.hand.x * 2.5 - STATE.rotation.y) * 1 * dt;
                } else {
                    STATE.rotation.y += (STATE.mode === 'TREE' ? CONFIG.treeRotate : CONFIG.scatterRotate) * dt;
                    STATE.rotation.x += (0 - STATE.rotation.x) * 2 * dt;
                }
                mainGroup.rotation.y = STATE.rotation.y;
                mainGroup.rotation.x = STATE.rotation.x;
            } else {
                mainGroup.rotation.y += 0.05 * dt;
            }
            
            // é¡¶éƒ¨æ˜Ÿæ˜ŸåŠ¨ç”»
            if (window.topStar) {
                const time = clock.elapsedTime;
                // ç¼“æ…¢æ—‹è½¬
                window.topStar.rotation.z += 0.3 * dt;
                // ä¸Šä¸‹æ¼‚æµ®
                window.topStar.position.y = 13.5 + Math.sin(time * 1.5) * 0.2;
                // æ˜Ÿæ˜Ÿæ•´ä½“å‘å…‰é—ªçƒ - æ…¢æ…¢å˜åŒ–
                const glowIntensity = CONFIG.starGlow + Math.sin(time * CONFIG.starBlink) * 1.0;
                MATERIALS.star.emissiveIntensity = glowIntensity;
                // ç‚¹å…‰æºåŒæ­¥é—ªçƒ
                if (window.starLight) {
                    window.starLight.position.y = window.topStar.position.y;
                    window.starLight.intensity = 2 + Math.sin(time * 0.8) * 1.5;
                }
            }
            
            // é›ªèŠ±åŠ¨ç”»
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= CONFIG.snowSpeed;
                    if (positions[i] < -10) positions[i] = 40;
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // æ›´æ–°ç²’å­
            particleSystem.forEach(p => p.update(dt, STATE.mode));
            composer.render();
        }
        
        function createTips(){
            const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
            const tips = document.createElement('div');
            tips.id = 'tips';
            
            if (isMobile) {
                // ç§»åŠ¨ç«¯æç¤º
                tips.innerHTML = `
                    <div style="text-align:center; margin-bottom:10px; color:#fff; font-weight:bold;">è§¦æ‘¸æ§åˆ¶</div>
                    <div class="tip-item"><span class="tip-key">ğŸ„</span> åœ£è¯æ ‘æ¨¡å¼</div>
                    <div class="tip-item"><span class="tip-key">âœ¨</span> æ˜Ÿæ²³æ•£å¼€</div>
                    <div class="tip-item"><span class="tip-key">ğŸ“·</span> é”å®šç…§ç‰‡</div>
                    <div class="tip-item"><span class="tip-key">â­ï¸</span> ä¸‹ä¸€å¼ </div>
                    <div class="tip-item"><span class="tip-key">å•æŒ‡æ»‘åŠ¨</span> æ—‹è½¬è§†è§’</div>
                    <div class="tip-item"><span class="tip-key">åŒæŒ‡æåˆ</span> ç¼©æ”¾å¤§å°</div>
                    <div class="tip-item"><span class="tip-key">åŒå‡»</span> é‡ç½®è§†è§’</div>
                    <div style="text-align:center; margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.1); color:rgba(0,255,204,0.6); font-size:9px;">
                        power by xiaohongshu-æ²«æ²« & Gemini3pro
                    </div>
                `;
            } else {
                // æ¡Œé¢ç«¯æç¤º
                tips.innerHTML = `
                    <div style="text-align:center; margin-bottom:10px; color:#fff; font-weight:bold;">æ‰‹åŠ¿æ§åˆ¶</div>
                    <div class="tip-item"><span class="tip-key">âœŠ æ¡æ‹³</span> åœ£è¯æ ‘</div>
                    <div class="tip-item"><span class="tip-key">âœ‹ å¼ æ‰‹</span> æ˜Ÿæ²³æ•£å¼€</div>
                    <div class="tip-item"><span class="tip-key">ğŸ‘Œ æåˆ</span> é”å®šç…§ç‰‡</div>
                    <div class="keyboard-tips">
                        <div style="text-align:center; margin-top:12px; margin-bottom:10px; color:#fff; font-weight:bold; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">é¼ æ ‡æ§åˆ¶</div>
                        <div class="tip-item"><span class="tip-key">å·¦é”®æ‹–åŠ¨</span> æ—‹è½¬è§†è§’</div>
                        <div class="tip-item"><span class="tip-key">å³é”®æ‹–åŠ¨</span> å¹³ç§»è§†è§’</div>
                        <div class="tip-item"><span class="tip-key">æ»šè½®</span> ç¼©æ”¾å¤§å°</div>
                        <div class="tip-item"><span class="tip-key">åŒå‡»</span> é‡ç½®è§†è§’</div>
                        <div style="text-align:center; margin-top:12px; margin-bottom:10px; color:#fff; font-weight:bold; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">é”®ç›˜æ§åˆ¶</div>
                        <div class="tip-item"><span class="tip-key">1 / T</span> åœ£è¯æ ‘</div>
                        <div class="tip-item"><span class="tip-key">2 / S</span> æ˜Ÿæ²³æ•£å¼€</div>
                        <div class="tip-item"><span class="tip-key">3 / P</span> é”å®šç…§ç‰‡</div>
                        <div class="tip-item"><span class="tip-key">N</span> ä¸‹ä¸€å¼ ç…§ç‰‡</div>
                        <div class="tip-item"><span class="tip-key">V</span> æ˜¾/éšæ‘„åƒå¤´</div>
                        <div class="tip-item"><span class="tip-key">F</span> å…¨å±åˆ‡æ¢</div>
                        <div class="tip-item"><span class="tip-key">H</span> æ˜¾/éšç•Œé¢</div>
                    </div>
                    <div style="text-align:center; margin-top:12px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.1); color:rgba(0,255,204,0.6); font-size:9px;">
                        power by xiaohongshu-æ²«æ²« & Gemini3pro
                    </div>
                `;
            }
            document.body.appendChild(tips);
        }async function init(){await PhotoCache.init();initThree();createMaterials();setupLights();createParticles();createSnow();await restorePhotosFromCache();await loadPresetPhotos();setupPostProcessing();setupEvents();createTips();await initMediaPipe();document['\u0067\u0065\u0074\u0045\u006C\u0065\u006D\u0065\u006E\u0074\u0042\u0079\u0049\u0064']("redaol".split("").reverse().join(""))['\u0073\u0074\u0079\u006C\u0065']['\u006F\u0070\u0061\u0063\u0069\u0074\u0079']=478283^478283;setTimeout(()=>document['\u0067\u0065\u0074\u0045\u006C\u0065\u006D\u0065\u006E\u0074\u0042\u0079\u0049\u0064']("\u006C\u006F\u0061\u0064\u0065\u0072")['\u0072\u0065\u006D\u006F\u0076\u0065'](),469601^469313);animate();}init();
    </script>

</body>
</html>
